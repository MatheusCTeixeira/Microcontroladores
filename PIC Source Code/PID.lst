CCS PCM C Compiler, Version 5.015, 5967               23-Jul-18 14:36

               Filename:   C:\Users\mathe\Documents\Microcontroladores\Microcontroladores\PIC Source Code\PID.lst

               ROM used:   3299 words (40%)
                           Largest free fragment is 2048
               RAM used:   105 (29%) at main() level
                           157 (43%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   1FD
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.5
0018:  GOTO   01B
0019:  BTFSC  0B.2
001A:  GOTO   036
001B:  BTFSS  0B.4
001C:  GOTO   01F
001D:  BTFSC  0B.1
001E:  GOTO   039
001F:  MOVLW  8C
0020:  MOVWF  04
0021:  BTFSS  00.5
0022:  GOTO   025
0023:  BTFSC  0C.5
0024:  GOTO   03C
0025:  MOVF   22,W
0026:  MOVWF  04
0027:  MOVF   23,W
0028:  MOVWF  77
0029:  MOVF   24,W
002A:  MOVWF  78
002B:  MOVF   25,W
002C:  MOVWF  79
002D:  MOVF   26,W
002E:  MOVWF  7A
002F:  MOVF   20,W
0030:  MOVWF  0A
0031:  SWAPF  21,W
0032:  MOVWF  03
0033:  SWAPF  7F,F
0034:  SWAPF  7F,W
0035:  RETFIE
0036:  BCF    0A.3
0037:  BCF    0A.4
0038:  GOTO   056
0039:  BCF    0A.3
003A:  BCF    0A.4
003B:  GOTO   0E7
003C:  BCF    0A.3
003D:  BCF    0A.4
003E:  GOTO   11E
.................... //#include <PID.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
003F:  BSF    03.5
0040:  MOVF   5D,W
0041:  CLRF   78
0042:  SUBWF  5C,W
0043:  BTFSC  03.0
0044:  GOTO   048
0045:  MOVF   5C,W
0046:  MOVWF  77
0047:  GOTO   054
0048:  CLRF   77
0049:  MOVLW  08
004A:  MOVWF  5E
004B:  RLF    5C,F
004C:  RLF    77,F
004D:  MOVF   5D,W
004E:  SUBWF  77,W
004F:  BTFSC  03.0
0050:  MOVWF  77
0051:  RLF    78,F
0052:  DECFSZ 5E,F
0053:  GOTO   04B
0054:  BCF    03.5
0055:  RETURN
*
0087:  MOVLW  8E
0088:  MOVWF  77
0089:  BSF    03.5
008A:  MOVF   5D,W
008B:  MOVWF  78
008C:  MOVF   5C,W
008D:  MOVWF  79
008E:  CLRF   7A
008F:  MOVF   78,F
0090:  BTFSS  03.2
0091:  GOTO   09C
0092:  MOVF   79,W
0093:  MOVWF  78
0094:  CLRF   79
0095:  MOVLW  08
0096:  SUBWF  77,F
0097:  MOVF   78,F
0098:  BTFSS  03.2
0099:  GOTO   09C
009A:  CLRF   77
009B:  GOTO   0A4
009C:  BCF    03.0
009D:  BTFSC  78.7
009E:  GOTO   0A3
009F:  RLF    79,F
00A0:  RLF    78,F
00A1:  DECF   77,F
00A2:  GOTO   09C
00A3:  BCF    78.7
00A4:  BCF    03.5
00A5:  RETURN
00A6:  BSF    03.5
00A7:  MOVF   5D,W
00A8:  MOVWF  64
00A9:  MOVF   61,W
00AA:  XORWF  64,F
00AB:  BTFSS  64.7
00AC:  GOTO   0B2
00AD:  BCF    03.2
00AE:  BCF    03.0
00AF:  BTFSC  5D.7
00B0:  BSF    03.0
00B1:  GOTO   0E5
00B2:  MOVF   5D,W
00B3:  MOVWF  64
00B4:  MOVF   60,W
00B5:  MOVWF  65
00B6:  MOVF   5C,W
00B7:  SUBWF  65,F
00B8:  BTFSC  03.2
00B9:  GOTO   0C0
00BA:  BTFSS  64.7
00BB:  GOTO   0E5
00BC:  MOVF   03,W
00BD:  XORLW  01
00BE:  MOVWF  03
00BF:  GOTO   0E5
00C0:  MOVF   61,W
00C1:  MOVWF  65
00C2:  MOVF   5D,W
00C3:  SUBWF  65,F
00C4:  BTFSC  03.2
00C5:  GOTO   0CC
00C6:  BTFSS  64.7
00C7:  GOTO   0E5
00C8:  MOVF   03,W
00C9:  XORLW  01
00CA:  MOVWF  03
00CB:  GOTO   0E5
00CC:  MOVF   62,W
00CD:  MOVWF  65
00CE:  MOVF   5E,W
00CF:  SUBWF  65,F
00D0:  BTFSC  03.2
00D1:  GOTO   0D8
00D2:  BTFSS  64.7
00D3:  GOTO   0E5
00D4:  MOVF   03,W
00D5:  XORLW  01
00D6:  MOVWF  03
00D7:  GOTO   0E5
00D8:  MOVF   63,W
00D9:  MOVWF  65
00DA:  MOVF   5F,W
00DB:  SUBWF  65,F
00DC:  BTFSC  03.2
00DD:  GOTO   0E4
00DE:  BTFSS  64.7
00DF:  GOTO   0E5
00E0:  MOVF   03,W
00E1:  XORLW  01
00E2:  MOVWF  03
00E3:  GOTO   0E5
00E4:  BCF    03.0
00E5:  BCF    03.5
00E6:  RETURN
*
01C4:  BSF    03.5
01C5:  MOVF   41,W
01C6:  BTFSC  03.2
01C7:  GOTO   28A
01C8:  MOVWF  4D
01C9:  MOVF   45,W
01CA:  BTFSC  03.2
01CB:  GOTO   28A
01CC:  SUBWF  4D,F
01CD:  BTFSS  03.0
01CE:  GOTO   1D4
01CF:  MOVLW  7F
01D0:  ADDWF  4D,F
01D1:  BTFSC  03.0
01D2:  GOTO   28A
01D3:  GOTO   1DA
01D4:  MOVLW  81
01D5:  SUBWF  4D,F
01D6:  BTFSS  03.0
01D7:  GOTO   28A
01D8:  BTFSC  03.2
01D9:  GOTO   28A
01DA:  MOVF   4D,W
01DB:  MOVWF  77
01DC:  CLRF   78
01DD:  CLRF   79
01DE:  CLRF   7A
01DF:  CLRF   4C
01E0:  MOVF   42,W
01E1:  MOVWF  4B
01E2:  BSF    4B.7
01E3:  MOVF   43,W
01E4:  MOVWF  4A
01E5:  MOVF   44,W
01E6:  MOVWF  49
01E7:  MOVLW  19
01E8:  MOVWF  4D
01E9:  MOVF   48,W
01EA:  SUBWF  49,F
01EB:  BTFSC  03.0
01EC:  GOTO   1FD
01ED:  MOVLW  01
01EE:  SUBWF  4A,F
01EF:  BTFSC  03.0
01F0:  GOTO   1FD
01F1:  SUBWF  4B,F
01F2:  BTFSC  03.0
01F3:  GOTO   1FD
01F4:  SUBWF  4C,F
01F5:  BTFSC  03.0
01F6:  GOTO   1FD
01F7:  INCF   4C,F
01F8:  INCF   4B,F
01F9:  INCF   4A,F
01FA:  MOVF   48,W
01FB:  ADDWF  49,F
01FC:  GOTO   22F
01FD:  MOVF   47,W
01FE:  SUBWF  4A,F
01FF:  BTFSC  03.0
0200:  GOTO   218
0201:  MOVLW  01
0202:  SUBWF  4B,F
0203:  BTFSC  03.0
0204:  GOTO   218
0205:  SUBWF  4C,F
0206:  BTFSC  03.0
0207:  GOTO   218
0208:  INCF   4C,F
0209:  INCF   4B,F
020A:  MOVF   47,W
020B:  ADDWF  4A,F
020C:  MOVF   48,W
020D:  ADDWF  49,F
020E:  BTFSS  03.0
020F:  GOTO   22F
0210:  INCF   4A,F
0211:  BTFSS  03.2
0212:  GOTO   22F
0213:  INCF   4B,F
0214:  BTFSS  03.2
0215:  GOTO   22F
0216:  INCF   4C,F
0217:  GOTO   22F
0218:  MOVF   46,W
0219:  IORLW  80
021A:  SUBWF  4B,F
021B:  BTFSC  03.0
021C:  GOTO   22E
021D:  MOVLW  01
021E:  SUBWF  4C,F
021F:  BTFSC  03.0
0220:  GOTO   22E
0221:  INCF   4C,F
0222:  MOVF   46,W
0223:  IORLW  80
0224:  ADDWF  4B,F
0225:  MOVF   47,W
0226:  ADDWF  4A,F
0227:  BTFSS  03.0
0228:  GOTO   20C
0229:  INCF   4B,F
022A:  BTFSS  03.2
022B:  GOTO   20C
022C:  INCF   4C,F
022D:  GOTO   20C
022E:  BSF    7A.0
022F:  DECFSZ 4D,F
0230:  GOTO   232
0231:  GOTO   23D
0232:  BCF    03.0
0233:  RLF    49,F
0234:  RLF    4A,F
0235:  RLF    4B,F
0236:  RLF    4C,F
0237:  BCF    03.0
0238:  RLF    7A,F
0239:  RLF    79,F
023A:  RLF    78,F
023B:  RLF    4E,F
023C:  GOTO   1E9
023D:  BTFSS  4E.0
023E:  GOTO   245
023F:  BCF    03.0
0240:  RRF    78,F
0241:  RRF    79,F
0242:  RRF    7A,F
0243:  RRF    4E,F
0244:  GOTO   248
0245:  DECF   77,F
0246:  BTFSC  03.2
0247:  GOTO   28A
0248:  BTFSC  4E.7
0249:  GOTO   271
024A:  BCF    03.0
024B:  RLF    49,F
024C:  RLF    4A,F
024D:  RLF    4B,F
024E:  RLF    4C,F
024F:  MOVF   48,W
0250:  SUBWF  49,F
0251:  BTFSC  03.0
0252:  GOTO   25D
0253:  MOVLW  01
0254:  SUBWF  4A,F
0255:  BTFSC  03.0
0256:  GOTO   25D
0257:  SUBWF  4B,F
0258:  BTFSC  03.0
0259:  GOTO   25D
025A:  SUBWF  4C,F
025B:  BTFSS  03.0
025C:  GOTO   280
025D:  MOVF   47,W
025E:  SUBWF  4A,F
025F:  BTFSC  03.0
0260:  GOTO   268
0261:  MOVLW  01
0262:  SUBWF  4B,F
0263:  BTFSC  03.0
0264:  GOTO   268
0265:  SUBWF  4C,F
0266:  BTFSS  03.0
0267:  GOTO   280
0268:  MOVF   46,W
0269:  IORLW  80
026A:  SUBWF  4B,F
026B:  BTFSC  03.0
026C:  GOTO   271
026D:  MOVLW  01
026E:  SUBWF  4C,F
026F:  BTFSS  03.0
0270:  GOTO   280
0271:  INCF   7A,F
0272:  BTFSS  03.2
0273:  GOTO   280
0274:  INCF   79,F
0275:  BTFSS  03.2
0276:  GOTO   280
0277:  INCF   78,F
0278:  BTFSS  03.2
0279:  GOTO   280
027A:  INCF   77,F
027B:  BTFSC  03.2
027C:  GOTO   28A
027D:  RRF    78,F
027E:  RRF    79,F
027F:  RRF    7A,F
0280:  MOVF   42,W
0281:  MOVWF  4D
0282:  MOVF   46,W
0283:  XORWF  4D,F
0284:  BTFSS  4D.7
0285:  GOTO   288
0286:  BSF    78.7
0287:  GOTO   28E
0288:  BCF    78.7
0289:  GOTO   28E
028A:  CLRF   77
028B:  CLRF   78
028C:  CLRF   79
028D:  CLRF   7A
028E:  BCF    03.5
028F:  RETURN
*
02C5:  MOVLW  8E
02C6:  MOVWF  77
02C7:  MOVF   38,W
02C8:  MOVWF  78
02C9:  MOVF   37,W
02CA:  MOVWF  79
02CB:  CLRF   7A
02CC:  BTFSS  38.7
02CD:  GOTO   2D3
02CE:  COMF   78,F
02CF:  COMF   79,F
02D0:  INCF   79,F
02D1:  BTFSC  03.2
02D2:  INCF   78,F
02D3:  MOVF   78,F
02D4:  BTFSS  03.2
02D5:  GOTO   2E0
02D6:  MOVF   79,W
02D7:  MOVWF  78
02D8:  CLRF   79
02D9:  MOVLW  08
02DA:  SUBWF  77,F
02DB:  MOVF   78,F
02DC:  BTFSS  03.2
02DD:  GOTO   2E0
02DE:  CLRF   77
02DF:  GOTO   2E9
02E0:  BCF    03.0
02E1:  BTFSC  78.7
02E2:  GOTO   2E7
02E3:  RLF    79,F
02E4:  RLF    78,F
02E5:  DECF   77,F
02E6:  GOTO   2E0
02E7:  BTFSS  38.7
02E8:  BCF    78.7
*
0404:  BSF    03.5
0405:  MOVF   4F,W
0406:  BTFSC  03.2
0407:  GOTO   475
0408:  MOVWF  57
0409:  MOVF   53,W
040A:  BTFSC  03.2
040B:  GOTO   475
040C:  ADDWF  57,F
040D:  BTFSC  03.0
040E:  GOTO   416
040F:  MOVLW  7F
0410:  SUBWF  57,F
0411:  BTFSS  03.0
0412:  GOTO   475
0413:  BTFSC  03.2
0414:  GOTO   475
0415:  GOTO   41A
0416:  MOVLW  81
0417:  ADDWF  57,F
0418:  BTFSC  03.0
0419:  GOTO   475
041A:  MOVF   57,W
041B:  MOVWF  77
041C:  CLRF   78
041D:  CLRF   79
041E:  CLRF   7A
041F:  MOVF   50,W
0420:  MOVWF  5B
0421:  BSF    5B.7
0422:  MOVF   51,W
0423:  MOVWF  5A
0424:  MOVF   52,W
0425:  MOVWF  59
0426:  MOVLW  18
0427:  MOVWF  57
0428:  CLRF   58
0429:  BTFSS  59.0
042A:  GOTO   443
042B:  MOVF   56,W
042C:  ADDWF  7A,F
042D:  BTFSS  03.0
042E:  GOTO   435
042F:  INCF   79,F
0430:  BTFSS  03.2
0431:  GOTO   435
0432:  INCF   78,F
0433:  BTFSC  03.2
0434:  BSF    58.7
0435:  MOVF   55,W
0436:  ADDWF  79,F
0437:  BTFSS  03.0
0438:  GOTO   43C
0439:  INCF   78,F
043A:  BTFSC  03.2
043B:  BSF    58.7
043C:  MOVF   54,W
043D:  MOVWF  51
043E:  BSF    51.7
043F:  MOVF   51,W
0440:  ADDWF  78,F
0441:  BTFSC  03.0
0442:  BSF    58.7
0443:  RLF    58,F
0444:  RRF    78,F
0445:  RRF    79,F
0446:  RRF    7A,F
0447:  RRF    5B,F
0448:  RRF    5A,F
0449:  RRF    59,F
044A:  BCF    03.0
044B:  DECFSZ 57,F
044C:  GOTO   428
044D:  MOVLW  01
044E:  ADDWF  77,F
044F:  BTFSC  03.0
0450:  GOTO   475
0451:  BTFSC  78.7
0452:  GOTO   45A
0453:  RLF    5B,F
0454:  RLF    7A,F
0455:  RLF    79,F
0456:  RLF    78,F
0457:  DECF   77,F
0458:  BTFSC  03.2
0459:  GOTO   475
045A:  BTFSS  5B.7
045B:  GOTO   46B
045C:  INCF   7A,F
045D:  BTFSS  03.2
045E:  GOTO   46B
045F:  INCF   79,F
0460:  BTFSS  03.2
0461:  GOTO   46B
0462:  INCF   78,F
0463:  BTFSS  03.2
0464:  GOTO   46B
0465:  RRF    78,F
0466:  RRF    79,F
0467:  RRF    7A,F
0468:  INCF   77,F
0469:  BTFSC  03.2
046A:  GOTO   475
046B:  MOVF   50,W
046C:  MOVWF  58
046D:  MOVF   54,W
046E:  XORWF  58,F
046F:  BTFSS  58.7
0470:  GOTO   473
0471:  BSF    78.7
0472:  GOTO   479
0473:  BCF    78.7
0474:  GOTO   479
0475:  CLRF   77
0476:  CLRF   78
0477:  CLRF   79
0478:  CLRF   7A
0479:  BCF    03.5
047A:  RETURN
047B:  MOVLW  80
047C:  BTFSS  03.1
047D:  GOTO   481
047E:  BSF    03.5
047F:  XORWF  46,F
0480:  BCF    03.5
0481:  BSF    03.5
0482:  CLRF   4B
0483:  CLRF   4C
0484:  MOVF   42,W
0485:  MOVWF  4A
0486:  MOVF   46,W
0487:  XORWF  4A,F
0488:  MOVF   41,W
0489:  BTFSC  03.2
048A:  GOTO   56F
048B:  MOVWF  49
048C:  MOVWF  77
048D:  MOVF   45,W
048E:  BTFSC  03.2
048F:  GOTO   578
0490:  SUBWF  49,F
0491:  BTFSC  03.2
0492:  GOTO   514
0493:  BTFSS  03.0
0494:  GOTO   4D2
0495:  MOVF   46,W
0496:  MOVWF  4F
0497:  BSF    4F.7
0498:  MOVF   47,W
0499:  MOVWF  4E
049A:  MOVF   48,W
049B:  MOVWF  4D
049C:  CLRF   4C
049D:  BCF    03.0
049E:  RRF    4F,F
049F:  RRF    4E,F
04A0:  RRF    4D,F
04A1:  RRF    4C,F
04A2:  DECFSZ 49,F
04A3:  GOTO   49C
04A4:  BTFSS  4A.7
04A5:  GOTO   4A9
04A6:  BSF    4B.0
04A7:  GOTO   58C
04A8:  BCF    4B.0
04A9:  BCF    49.0
04AA:  BSF    4B.4
04AB:  MOVLW  C4
04AC:  MOVWF  04
04AD:  BCF    03.7
04AE:  GOTO   5A1
04AF:  BCF    4B.4
04B0:  BTFSC  4A.7
04B1:  GOTO   4BC
04B2:  BTFSS  49.0
04B3:  GOTO   4C7
04B4:  RRF    4F,F
04B5:  RRF    4E,F
04B6:  RRF    4D,F
04B7:  RRF    4C,F
04B8:  INCF   77,F
04B9:  BTFSC  03.2
04BA:  GOTO   587
04BB:  GOTO   4C7
04BC:  BTFSC  4F.7
04BD:  GOTO   4CA
04BE:  BCF    03.0
04BF:  RLF    4C,F
04C0:  RLF    4D,F
04C1:  RLF    4E,F
04C2:  RLF    4F,F
04C3:  DECF   77,F
04C4:  BTFSC  03.2
04C5:  GOTO   587
04C6:  GOTO   4BC
04C7:  BSF    4B.6
04C8:  GOTO   534
04C9:  BCF    4B.6
04CA:  MOVF   42,W
04CB:  MOVWF  4A
04CC:  BTFSS  4A.7
04CD:  GOTO   4D0
04CE:  BSF    4F.7
04CF:  GOTO   580
04D0:  BCF    4F.7
04D1:  GOTO   580
04D2:  MOVF   45,W
04D3:  MOVWF  49
04D4:  MOVWF  77
04D5:  MOVF   41,W
04D6:  SUBWF  49,F
04D7:  MOVF   42,W
04D8:  MOVWF  4F
04D9:  BSF    4F.7
04DA:  MOVF   43,W
04DB:  MOVWF  4E
04DC:  MOVF   44,W
04DD:  MOVWF  4D
04DE:  CLRF   4C
04DF:  BCF    03.0
04E0:  RRF    4F,F
04E1:  RRF    4E,F
04E2:  RRF    4D,F
04E3:  RRF    4C,F
04E4:  DECFSZ 49,F
04E5:  GOTO   4DE
04E6:  BTFSS  4A.7
04E7:  GOTO   4EB
04E8:  BSF    4B.1
04E9:  GOTO   58C
04EA:  BCF    4B.1
04EB:  BCF    49.0
04EC:  BSF    4B.5
04ED:  MOVLW  C8
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  GOTO   5A1
04F1:  BCF    4B.5
04F2:  BTFSC  4A.7
04F3:  GOTO   4FE
04F4:  BTFSS  49.0
04F5:  GOTO   509
04F6:  RRF    4F,F
04F7:  RRF    4E,F
04F8:  RRF    4D,F
04F9:  RRF    4C,F
04FA:  INCF   77,F
04FB:  BTFSC  03.2
04FC:  GOTO   587
04FD:  GOTO   509
04FE:  BTFSC  4F.7
04FF:  GOTO   50C
0500:  BCF    03.0
0501:  RLF    4C,F
0502:  RLF    4D,F
0503:  RLF    4E,F
0504:  RLF    4F,F
0505:  DECF   77,F
0506:  BTFSC  03.2
0507:  GOTO   587
0508:  GOTO   4FE
0509:  BSF    4B.7
050A:  GOTO   534
050B:  BCF    4B.7
050C:  MOVF   46,W
050D:  MOVWF  4A
050E:  BTFSS  4A.7
050F:  GOTO   512
0510:  BSF    4F.7
0511:  GOTO   580
0512:  BCF    4F.7
0513:  GOTO   580
0514:  MOVF   46,W
0515:  MOVWF  4F
0516:  BSF    4F.7
0517:  MOVF   47,W
0518:  MOVWF  4E
0519:  MOVF   48,W
051A:  MOVWF  4D
051B:  BTFSS  4A.7
051C:  GOTO   521
051D:  BCF    4F.7
051E:  BSF    4B.2
051F:  GOTO   58C
0520:  BCF    4B.2
0521:  CLRF   4C
0522:  BCF    49.0
0523:  MOVLW  C4
0524:  MOVWF  04
0525:  BCF    03.7
0526:  GOTO   5A1
0527:  BTFSC  4A.7
0528:  GOTO   54A
0529:  MOVF   42,W
052A:  MOVWF  4A
052B:  BTFSS  49.0
052C:  GOTO   534
052D:  RRF    4F,F
052E:  RRF    4E,F
052F:  RRF    4D,F
0530:  RRF    4C,F
0531:  INCF   77,F
0532:  BTFSC  03.2
0533:  GOTO   587
0534:  BTFSS  4C.7
0535:  GOTO   545
0536:  INCF   4D,F
0537:  BTFSS  03.2
0538:  GOTO   545
0539:  INCF   4E,F
053A:  BTFSS  03.2
053B:  GOTO   545
053C:  INCF   4F,F
053D:  BTFSS  03.2
053E:  GOTO   545
053F:  RRF    4F,F
0540:  RRF    4E,F
0541:  RRF    4D,F
0542:  INCF   77,F
0543:  BTFSC  03.2
0544:  GOTO   587
0545:  BTFSC  4B.6
0546:  GOTO   4C9
0547:  BTFSC  4B.7
0548:  GOTO   50B
0549:  GOTO   569
054A:  MOVLW  80
054B:  XORWF  4F,F
054C:  BTFSS  4F.7
054D:  GOTO   552
054E:  GOTO   58C
054F:  MOVF   46,W
0550:  MOVWF  4A
0551:  GOTO   55F
0552:  MOVF   42,W
0553:  MOVWF  4A
0554:  MOVF   4F,F
0555:  BTFSS  03.2
0556:  GOTO   55F
0557:  MOVF   4E,F
0558:  BTFSS  03.2
0559:  GOTO   55F
055A:  MOVF   4D,F
055B:  BTFSS  03.2
055C:  GOTO   55F
055D:  CLRF   77
055E:  GOTO   580
055F:  BTFSC  4F.7
0560:  GOTO   569
0561:  BCF    03.0
0562:  RLF    4C,F
0563:  RLF    4D,F
0564:  RLF    4E,F
0565:  RLF    4F,F
0566:  DECFSZ 77,F
0567:  GOTO   55F
0568:  GOTO   587
0569:  BTFSS  4A.7
056A:  GOTO   56D
056B:  BSF    4F.7
056C:  GOTO   580
056D:  BCF    4F.7
056E:  GOTO   580
056F:  MOVF   45,W
0570:  MOVWF  77
0571:  MOVF   46,W
0572:  MOVWF  4F
0573:  MOVF   47,W
0574:  MOVWF  4E
0575:  MOVF   48,W
0576:  MOVWF  4D
0577:  GOTO   580
0578:  MOVF   41,W
0579:  MOVWF  77
057A:  MOVF   42,W
057B:  MOVWF  4F
057C:  MOVF   43,W
057D:  MOVWF  4E
057E:  MOVF   44,W
057F:  MOVWF  4D
0580:  MOVF   4F,W
0581:  MOVWF  78
0582:  MOVF   4E,W
0583:  MOVWF  79
0584:  MOVF   4D,W
0585:  MOVWF  7A
0586:  GOTO   5BF
0587:  CLRF   77
0588:  CLRF   78
0589:  CLRF   79
058A:  CLRF   7A
058B:  GOTO   5BF
058C:  CLRF   4C
058D:  COMF   4D,F
058E:  COMF   4E,F
058F:  COMF   4F,F
0590:  COMF   4C,F
0591:  INCF   4C,F
0592:  BTFSS  03.2
0593:  GOTO   59A
0594:  INCF   4D,F
0595:  BTFSS  03.2
0596:  GOTO   59A
0597:  INCF   4E,F
0598:  BTFSC  03.2
0599:  INCF   4F,F
059A:  BTFSC  4B.0
059B:  GOTO   4A8
059C:  BTFSC  4B.1
059D:  GOTO   4EA
059E:  BTFSC  4B.2
059F:  GOTO   520
05A0:  GOTO   54F
05A1:  MOVF   00,W
05A2:  ADDWF  4D,F
05A3:  BTFSS  03.0
05A4:  GOTO   5AB
05A5:  INCF   4E,F
05A6:  BTFSS  03.2
05A7:  GOTO   5AB
05A8:  INCF   4F,F
05A9:  BTFSC  03.2
05AA:  BSF    49.0
05AB:  DECF   04,F
05AC:  MOVF   00,W
05AD:  ADDWF  4E,F
05AE:  BTFSS  03.0
05AF:  GOTO   5B3
05B0:  INCF   4F,F
05B1:  BTFSC  03.2
05B2:  BSF    49.0
05B3:  DECF   04,F
05B4:  MOVF   00,W
05B5:  BTFSS  00.7
05B6:  XORLW  80
05B7:  ADDWF  4F,F
05B8:  BTFSC  03.0
05B9:  BSF    49.0
05BA:  BTFSC  4B.4
05BB:  GOTO   4AF
05BC:  BTFSC  4B.5
05BD:  GOTO   4F1
05BE:  GOTO   527
05BF:  BCF    03.5
05C0:  RETURN
*
071E:  BSF    03.5
071F:  MOVF   4F,W
0720:  SUBLW  B6
0721:  MOVWF  4F
0722:  CLRF   7A
0723:  MOVF   50,W
0724:  MOVWF  53
0725:  BSF    50.7
0726:  BCF    03.0
0727:  RRF    50,F
0728:  RRF    51,F
0729:  RRF    52,F
072A:  RRF    7A,F
072B:  RRF    79,F
072C:  RRF    78,F
072D:  RRF    77,F
072E:  DECFSZ 4F,F
072F:  GOTO   726
0730:  BTFSS  53.7
0731:  GOTO   73D
0732:  COMF   77,F
0733:  COMF   78,F
0734:  COMF   79,F
0735:  COMF   7A,F
0736:  INCF   77,F
0737:  BTFSC  03.2
0738:  INCF   78,F
0739:  BTFSC  03.2
073A:  INCF   79,F
073B:  BTFSC  03.2
073C:  INCF   7A,F
073D:  BCF    03.5
073E:  RETURN
073F:  BTFSC  03.1
0740:  GOTO   744
0741:  MOVLW  D7
0742:  MOVWF  04
0743:  BCF    03.7
0744:  CLRF   77
0745:  CLRF   78
0746:  CLRF   79
0747:  CLRF   7A
0748:  BSF    03.5
0749:  CLRF   57
074A:  CLRF   58
074B:  CLRF   59
074C:  CLRF   5A
074D:  MOVF   56,W
074E:  IORWF  55,W
074F:  IORWF  54,W
0750:  IORWF  53,W
0751:  BTFSC  03.2
0752:  GOTO   783
0753:  MOVLW  20
0754:  MOVWF  5B
0755:  BCF    03.0
0756:  RLF    4F,F
0757:  RLF    50,F
0758:  RLF    51,F
0759:  RLF    52,F
075A:  RLF    57,F
075B:  RLF    58,F
075C:  RLF    59,F
075D:  RLF    5A,F
075E:  MOVF   56,W
075F:  SUBWF  5A,W
0760:  BTFSS  03.2
0761:  GOTO   76C
0762:  MOVF   55,W
0763:  SUBWF  59,W
0764:  BTFSS  03.2
0765:  GOTO   76C
0766:  MOVF   54,W
0767:  SUBWF  58,W
0768:  BTFSS  03.2
0769:  GOTO   76C
076A:  MOVF   53,W
076B:  SUBWF  57,W
076C:  BTFSS  03.0
076D:  GOTO   77D
076E:  MOVF   53,W
076F:  SUBWF  57,F
0770:  MOVF   54,W
0771:  BTFSS  03.0
0772:  INCFSZ 54,W
0773:  SUBWF  58,F
0774:  MOVF   55,W
0775:  BTFSS  03.0
0776:  INCFSZ 55,W
0777:  SUBWF  59,F
0778:  MOVF   56,W
0779:  BTFSS  03.0
077A:  INCFSZ 56,W
077B:  SUBWF  5A,F
077C:  BSF    03.0
077D:  RLF    77,F
077E:  RLF    78,F
077F:  RLF    79,F
0780:  RLF    7A,F
0781:  DECFSZ 5B,F
0782:  GOTO   755
0783:  MOVF   57,W
0784:  MOVWF  00
0785:  INCF   04,F
0786:  MOVF   58,W
0787:  MOVWF  00
0788:  INCF   04,F
0789:  MOVF   59,W
078A:  MOVWF  00
078B:  INCF   04,F
078C:  MOVF   5A,W
078D:  MOVWF  00
078E:  BCF    03.5
078F:  RETURN
*
07B2:  MOVF   36,W
07B3:  MOVWF  04
07B4:  BCF    03.7
07B5:  BTFSC  37.0
07B6:  BSF    03.7
07B7:  BSF    03.5
07B8:  MOVF   4F,W
07B9:  MOVWF  00
07BA:  INCF   04,F
07BB:  CLRF   00
07BC:  BCF    03.5
07BD:  INCF   36,F
07BE:  BTFSC  03.2
07BF:  INCF   37,F
07C0:  RETURN
*
0800:  MOVF   04,W
0801:  BSF    03.5
0802:  MOVWF  33
0803:  MOVF   32,W
0804:  MOVWF  35
0805:  BTFSC  03.2
0806:  GOTO   024
0807:  MOVF   31,W
0808:  MOVWF  52
0809:  MOVF   30,W
080A:  MOVWF  51
080B:  MOVF   2F,W
080C:  MOVWF  50
080D:  MOVF   2E,W
080E:  MOVWF  4F
080F:  CLRF   56
0810:  CLRF   55
0811:  MOVLW  20
0812:  MOVWF  54
0813:  MOVLW  82
0814:  MOVWF  53
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   404
0818:  BSF    0A.3
0819:  MOVF   7A,W
081A:  BSF    03.5
081B:  MOVWF  31
081C:  MOVF   79,W
081D:  MOVWF  30
081E:  MOVF   78,W
081F:  MOVWF  2F
0820:  MOVF   77,W
0821:  MOVWF  2E
0822:  DECFSZ 35,F
0823:  GOTO   007
0824:  MOVF   31,W
0825:  MOVWF  52
0826:  MOVF   30,W
0827:  MOVWF  51
0828:  MOVF   2F,W
0829:  MOVWF  50
082A:  MOVF   2E,W
082B:  MOVWF  4F
082C:  BCF    0A.3
082D:  BCF    03.5
082E:  CALL   71E
082F:  BSF    0A.3
0830:  MOVF   7A,W
0831:  BSF    03.5
0832:  MOVWF  31
0833:  MOVF   79,W
0834:  MOVWF  30
0835:  MOVF   78,W
0836:  MOVWF  2F
0837:  MOVF   77,W
0838:  MOVWF  2E
0839:  BTFSS  31.7
083A:  GOTO   048
083B:  DECF   33,F
083C:  BSF    33.5
083D:  COMF   2E,F
083E:  COMF   2F,F
083F:  COMF   30,F
0840:  COMF   31,F
0841:  INCF   2E,F
0842:  BTFSC  03.2
0843:  INCF   2F,F
0844:  BTFSC  03.2
0845:  INCF   30,F
0846:  BTFSC  03.2
0847:  INCF   31,F
0848:  MOVLW  3B
0849:  MOVWF  3A
084A:  MOVLW  9A
084B:  MOVWF  39
084C:  MOVLW  CA
084D:  MOVWF  38
084E:  CLRF   37
084F:  MOVLW  0A
0850:  MOVWF  35
0851:  MOVF   32,W
0852:  BTFSC  03.2
0853:  INCF   33,F
0854:  BSF    03.1
0855:  MOVLW  AE
0856:  MOVWF  04
0857:  BCF    03.7
0858:  MOVF   31,W
0859:  MOVWF  52
085A:  MOVF   30,W
085B:  MOVWF  51
085C:  MOVF   2F,W
085D:  MOVWF  50
085E:  MOVF   2E,W
085F:  MOVWF  4F
0860:  MOVF   3A,W
0861:  MOVWF  56
0862:  MOVF   39,W
0863:  MOVWF  55
0864:  MOVF   38,W
0865:  MOVWF  54
0866:  MOVF   37,W
0867:  MOVWF  53
0868:  BCF    0A.3
0869:  BCF    03.5
086A:  CALL   73F
086B:  BSF    0A.3
086C:  MOVF   78,W
086D:  MOVF   77,F
086E:  BTFSS  03.2
086F:  GOTO   087
0870:  BSF    03.5
0871:  INCF   32,W
0872:  SUBWF  35,W
0873:  BTFSS  03.2
0874:  GOTO   077
0875:  BCF    03.5
0876:  GOTO   087
0877:  MOVF   33,W
0878:  BTFSC  03.2
0879:  GOTO   08A
087A:  ANDLW  0F
087B:  SUBWF  35,W
087C:  BTFSC  03.2
087D:  GOTO   080
087E:  BTFSC  03.0
087F:  GOTO   0CA
0880:  BTFSC  33.7
0881:  GOTO   0CA
0882:  BTFSC  33.6
0883:  GOTO   08A
0884:  MOVLW  20
0885:  GOTO   0C2
0886:  BCF    03.5
0887:  MOVLW  20
0888:  BSF    03.5
0889:  ANDWF  33,F
088A:  BTFSS  33.5
088B:  GOTO   09C
088C:  BCF    33.5
088D:  MOVF   32,W
088E:  BTFSS  03.2
088F:  DECF   33,F
0890:  MOVF   77,W
0891:  MOVWF  33
0892:  MOVLW  2D
0893:  MOVWF  3B
0894:  BCF    0A.3
0895:  BCF    03.5
0896:  CALL   707
0897:  BSF    0A.3
0898:  BSF    03.5
0899:  MOVF   33,W
089A:  MOVWF  77
089B:  CLRF   33
089C:  MOVF   32,W
089D:  SUBWF  35,W
089E:  BTFSS  03.2
089F:  GOTO   0AE
08A0:  MOVF   77,W
08A1:  MOVWF  33
08A2:  MOVLW  2E
08A3:  MOVWF  3B
08A4:  BCF    0A.3
08A5:  BCF    03.5
08A6:  CALL   707
08A7:  BSF    0A.3
08A8:  BSF    03.5
08A9:  MOVF   33,W
08AA:  MOVWF  77
08AB:  MOVLW  20
08AC:  ANDWF  33,F
08AD:  MOVLW  00
08AE:  MOVLW  30
08AF:  BTFSS  33.5
08B0:  GOTO   0C2
08B1:  BCF    33.5
08B2:  MOVF   32,W
08B3:  BTFSS  03.2
08B4:  DECF   33,F
08B5:  MOVF   77,W
08B6:  MOVWF  33
08B7:  MOVLW  2D
08B8:  MOVWF  3B
08B9:  BCF    0A.3
08BA:  BCF    03.5
08BB:  CALL   707
08BC:  BSF    0A.3
08BD:  BSF    03.5
08BE:  MOVF   33,W
08BF:  MOVWF  77
08C0:  CLRF   33
08C1:  MOVLW  30
08C2:  ADDWF  77,F
08C3:  MOVF   77,W
08C4:  MOVWF  3B
08C5:  BCF    0A.3
08C6:  BCF    03.5
08C7:  CALL   707
08C8:  BSF    0A.3
08C9:  BSF    03.5
08CA:  BCF    03.1
08CB:  MOVF   3A,W
08CC:  MOVWF  52
08CD:  MOVF   39,W
08CE:  MOVWF  51
08CF:  MOVF   38,W
08D0:  MOVWF  50
08D1:  MOVF   37,W
08D2:  MOVWF  4F
08D3:  CLRF   56
08D4:  CLRF   55
08D5:  CLRF   54
08D6:  MOVLW  0A
08D7:  MOVWF  53
08D8:  BCF    0A.3
08D9:  BCF    03.5
08DA:  CALL   73F
08DB:  BSF    0A.3
08DC:  MOVF   7A,W
08DD:  BSF    03.5
08DE:  MOVWF  3A
08DF:  MOVF   79,W
08E0:  MOVWF  39
08E1:  MOVF   78,W
08E2:  MOVWF  38
08E3:  MOVF   77,W
08E4:  MOVWF  37
08E5:  DECFSZ 35,F
08E6:  GOTO   054
08E7:  BCF    03.5
08E8:  RETURN
08E9:  MOVF   04,W
08EA:  BSF    03.5
08EB:  MOVWF  47
08EC:  MOVF   46,W
08ED:  MOVWF  49
08EE:  BTFSC  03.2
08EF:  GOTO   10D
08F0:  MOVF   45,W
08F1:  MOVWF  52
08F2:  MOVF   44,W
08F3:  MOVWF  51
08F4:  MOVF   43,W
08F5:  MOVWF  50
08F6:  MOVF   42,W
08F7:  MOVWF  4F
08F8:  CLRF   56
08F9:  CLRF   55
08FA:  MOVLW  20
08FB:  MOVWF  54
08FC:  MOVLW  82
08FD:  MOVWF  53
08FE:  BCF    0A.3
08FF:  BCF    03.5
0900:  CALL   404
0901:  BSF    0A.3
0902:  MOVF   7A,W
0903:  BSF    03.5
0904:  MOVWF  45
0905:  MOVF   79,W
0906:  MOVWF  44
0907:  MOVF   78,W
0908:  MOVWF  43
0909:  MOVF   77,W
090A:  MOVWF  42
090B:  DECFSZ 49,F
090C:  GOTO   0F0
090D:  MOVF   45,W
090E:  MOVWF  52
090F:  MOVF   44,W
0910:  MOVWF  51
0911:  MOVF   43,W
0912:  MOVWF  50
0913:  MOVF   42,W
0914:  MOVWF  4F
0915:  BCF    0A.3
0916:  BCF    03.5
0917:  CALL   71E
0918:  BSF    0A.3
0919:  MOVF   7A,W
091A:  BSF    03.5
091B:  MOVWF  45
091C:  MOVF   79,W
091D:  MOVWF  44
091E:  MOVF   78,W
091F:  MOVWF  43
0920:  MOVF   77,W
0921:  MOVWF  42
0922:  BTFSS  45.7
0923:  GOTO   131
0924:  DECF   47,F
0925:  BSF    47.5
0926:  COMF   42,F
0927:  COMF   43,F
0928:  COMF   44,F
0929:  COMF   45,F
092A:  INCF   42,F
092B:  BTFSC  03.2
092C:  INCF   43,F
092D:  BTFSC  03.2
092E:  INCF   44,F
092F:  BTFSC  03.2
0930:  INCF   45,F
0931:  MOVLW  3B
0932:  MOVWF  4E
0933:  MOVLW  9A
0934:  MOVWF  4D
0935:  MOVLW  CA
0936:  MOVWF  4C
0937:  CLRF   4B
0938:  MOVLW  0A
0939:  MOVWF  49
093A:  MOVF   46,W
093B:  BTFSC  03.2
093C:  INCF   47,F
093D:  BSF    03.1
093E:  MOVLW  C2
093F:  MOVWF  04
0940:  BCF    03.7
0941:  MOVF   45,W
0942:  MOVWF  52
0943:  MOVF   44,W
0944:  MOVWF  51
0945:  MOVF   43,W
0946:  MOVWF  50
0947:  MOVF   42,W
0948:  MOVWF  4F
0949:  MOVF   4E,W
094A:  MOVWF  56
094B:  MOVF   4D,W
094C:  MOVWF  55
094D:  MOVF   4C,W
094E:  MOVWF  54
094F:  MOVF   4B,W
0950:  MOVWF  53
0951:  BCF    0A.3
0952:  BCF    03.5
0953:  CALL   73F
0954:  BSF    0A.3
0955:  MOVF   78,W
0956:  MOVF   77,F
0957:  BTFSS  03.2
0958:  GOTO   170
0959:  BSF    03.5
095A:  INCF   46,W
095B:  SUBWF  49,W
095C:  BTFSS  03.2
095D:  GOTO   160
095E:  BCF    03.5
095F:  GOTO   170
0960:  MOVF   47,W
0961:  BTFSC  03.2
0962:  GOTO   173
0963:  ANDLW  0F
0964:  SUBWF  49,W
0965:  BTFSC  03.2
0966:  GOTO   169
0967:  BTFSC  03.0
0968:  GOTO   1B3
0969:  BTFSC  47.7
096A:  GOTO   1B3
096B:  BTFSC  47.6
096C:  GOTO   173
096D:  MOVLW  20
096E:  GOTO   1AB
096F:  BCF    03.5
0970:  MOVLW  20
0971:  BSF    03.5
0972:  ANDWF  47,F
0973:  BTFSS  47.5
0974:  GOTO   185
0975:  BCF    47.5
0976:  MOVF   46,W
0977:  BTFSS  03.2
0978:  DECF   47,F
0979:  MOVF   77,W
097A:  MOVWF  47
097B:  MOVLW  2D
097C:  MOVWF  4F
097D:  BCF    0A.3
097E:  BCF    03.5
097F:  CALL   7B2
0980:  BSF    0A.3
0981:  BSF    03.5
0982:  MOVF   47,W
0983:  MOVWF  77
0984:  CLRF   47
0985:  MOVF   46,W
0986:  SUBWF  49,W
0987:  BTFSS  03.2
0988:  GOTO   197
0989:  MOVF   77,W
098A:  MOVWF  47
098B:  MOVLW  2E
098C:  MOVWF  4F
098D:  BCF    0A.3
098E:  BCF    03.5
098F:  CALL   7B2
0990:  BSF    0A.3
0991:  BSF    03.5
0992:  MOVF   47,W
0993:  MOVWF  77
0994:  MOVLW  20
0995:  ANDWF  47,F
0996:  MOVLW  00
0997:  MOVLW  30
0998:  BTFSS  47.5
0999:  GOTO   1AB
099A:  BCF    47.5
099B:  MOVF   46,W
099C:  BTFSS  03.2
099D:  DECF   47,F
099E:  MOVF   77,W
099F:  MOVWF  47
09A0:  MOVLW  2D
09A1:  MOVWF  4F
09A2:  BCF    0A.3
09A3:  BCF    03.5
09A4:  CALL   7B2
09A5:  BSF    0A.3
09A6:  BSF    03.5
09A7:  MOVF   47,W
09A8:  MOVWF  77
09A9:  CLRF   47
09AA:  MOVLW  30
09AB:  ADDWF  77,F
09AC:  MOVF   77,W
09AD:  MOVWF  4F
09AE:  BCF    0A.3
09AF:  BCF    03.5
09B0:  CALL   7B2
09B1:  BSF    0A.3
09B2:  BSF    03.5
09B3:  BCF    03.1
09B4:  MOVF   4E,W
09B5:  MOVWF  52
09B6:  MOVF   4D,W
09B7:  MOVWF  51
09B8:  MOVF   4C,W
09B9:  MOVWF  50
09BA:  MOVF   4B,W
09BB:  MOVWF  4F
09BC:  CLRF   56
09BD:  CLRF   55
09BE:  CLRF   54
09BF:  MOVLW  0A
09C0:  MOVWF  53
09C1:  BCF    0A.3
09C2:  BCF    03.5
09C3:  CALL   73F
09C4:  BSF    0A.3
09C5:  MOVF   7A,W
09C6:  BSF    03.5
09C7:  MOVWF  4E
09C8:  MOVF   79,W
09C9:  MOVWF  4D
09CA:  MOVF   78,W
09CB:  MOVWF  4C
09CC:  MOVF   77,W
09CD:  MOVWF  4B
09CE:  DECFSZ 49,F
09CF:  GOTO   13D
09D0:  BCF    03.5
09D1:  BCF    0A.3
09D2:  BCF    0A.4
09D3:  GOTO   7D4 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
0141:  MOVLW  03
0142:  BSF    03.5
0143:  SUBWF  38,F
0144:  BTFSS  03.0
0145:  GOTO   150
0146:  MOVLW  B8
0147:  MOVWF  04
0148:  BCF    03.7
0149:  MOVF   00,W
014A:  BTFSC  03.2
014B:  GOTO   150
014C:  GOTO   14E
014D:  GOTO   14E
014E:  DECFSZ 00,F
014F:  GOTO   14D
0150:  BCF    03.5
0151:  RETURN
*
0313:  MOVLW  B2
0314:  MOVWF  04
0315:  BCF    03.7
0316:  MOVF   00,W
0317:  BTFSC  03.2
0318:  GOTO   326
0319:  MOVLW  06
031A:  MOVWF  78
031B:  CLRF   77
031C:  DECFSZ 77,F
031D:  GOTO   31C
031E:  DECFSZ 78,F
031F:  GOTO   31B
0320:  MOVLW  7B
0321:  MOVWF  77
0322:  DECFSZ 77,F
0323:  GOTO   322
0324:  DECFSZ 00,F
0325:  GOTO   319
0326:  RETURN
.................... #use rs232(baud=9600,parity=E,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
*
0707:  MOVLW  08
0708:  MOVWF  78
0709:  BSF    03.5
070A:  CLRF   3C
070B:  MOVF   3B,W
070C:  MOVWF  77
070D:  MOVF   77,W
070E:  XORWF  3C,F
070F:  RRF    77,F
0710:  DECFSZ 78,F
0711:  GOTO   70D
0712:  BCF    03.5
0713:  BTFSS  0C.4
0714:  GOTO   713
0715:  MOVLW  FE
0716:  BSF    03.5
0717:  ANDWF  18,F
0718:  BTFSC  3C.0
0719:  BSF    18.0
071A:  MOVF   3B,W
071B:  BCF    03.5
071C:  MOVWF  19
071D:  RETURN
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C5) 
*
0327:  MOVLW  08
0328:  MOVWF  78
0329:  NOP
032A:  BCF    07.5
032B:  BCF    28.5
032C:  MOVF   28,W
032D:  BSF    03.5
032E:  MOVWF  07
032F:  NOP
0330:  RLF    51,F
0331:  BCF    03.5
0332:  BCF    07.4
0333:  BTFSS  03.0
0334:  GOTO   33B
0335:  BSF    28.4
0336:  MOVF   28,W
0337:  BSF    03.5
0338:  MOVWF  07
0339:  GOTO   33F
033A:  BCF    03.5
033B:  BCF    28.4
033C:  MOVF   28,W
033D:  BSF    03.5
033E:  MOVWF  07
033F:  NOP
0340:  BCF    03.5
0341:  BSF    28.5
0342:  MOVF   28,W
0343:  BSF    03.5
0344:  MOVWF  07
0345:  BCF    03.5
0346:  BTFSS  07.5
0347:  GOTO   346
0348:  DECFSZ 78,F
0349:  GOTO   329
034A:  NOP
034B:  BCF    07.5
034C:  BCF    28.5
034D:  MOVF   28,W
034E:  BSF    03.5
034F:  MOVWF  07
0350:  NOP
0351:  BCF    03.5
0352:  BSF    28.4
0353:  MOVF   28,W
0354:  BSF    03.5
0355:  MOVWF  07
0356:  NOP
0357:  NOP
0358:  BCF    03.5
0359:  BSF    28.5
035A:  MOVF   28,W
035B:  BSF    03.5
035C:  MOVWF  07
035D:  BCF    03.5
035E:  BTFSS  07.5
035F:  GOTO   35E
0360:  CLRF   78
0361:  NOP
0362:  BTFSC  07.4
0363:  BSF    78.0
0364:  BCF    07.5
0365:  BCF    28.5
0366:  MOVF   28,W
0367:  BSF    03.5
0368:  MOVWF  07
0369:  BCF    03.5
036A:  BCF    07.4
036B:  BCF    28.4
036C:  MOVF   28,W
036D:  BSF    03.5
036E:  MOVWF  07
036F:  BCF    03.5
0370:  RETURN
....................  
....................   
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0A3A:  BCF    03.5
0A3B:  CLRF   29
0A3C:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
05C1:  BSF    03.5
05C2:  CLRF   35
05C3:  CLRF   34
05C4:  CLRF   33
05C5:  MOVLW  7F
05C6:  MOVWF  32
05C7:  CLRF   39
05C8:  CLRF   38
05C9:  CLRF   37
05CA:  CLRF   36
05CB:  BSF    3A.0
05CC:  BCF    3A.1
05CD:  BCF    3A.2
05CE:  CLRF   3C
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
05CF:  MOVF   2E,W
05D0:  IORWF  2F,W
05D1:  BTFSS  03.2
05D2:  GOTO   5D8
....................       return 0; 
05D3:  CLRF   77
05D4:  CLRF   78
05D5:  CLRF   79
05D6:  CLRF   7A
05D7:  GOTO   703
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
05D8:  MOVF   3C,W
05D9:  INCF   3C,F
05DA:  ADDWF  2E,W
05DB:  MOVWF  04
05DC:  BCF    03.7
05DD:  BTFSC  2F.0
05DE:  BSF    03.7
05DF:  MOVF   00,W
05E0:  MOVWF  3B
05E1:  MOVF   3B,F
05E2:  BTFSC  03.2
05E3:  GOTO   6BF
....................    { 
....................       if (skip && !isspace(c)) 
05E4:  BTFSS  3A.0
05E5:  GOTO   5F8
05E6:  MOVF   3B,W
05E7:  SUBLW  20
05E8:  BTFSC  03.2
05E9:  GOTO   5F8
....................       { 
....................          skip = 0; 
05EA:  BCF    3A.0
....................          if (c == '+') 
05EB:  MOVF   3B,W
05EC:  SUBLW  2B
05ED:  BTFSS  03.2
05EE:  GOTO   5F2
....................          { 
....................             sign = 0; 
05EF:  BCF    3A.1
....................             continue; 
05F0:  GOTO   6B5
....................          }             
05F1:  GOTO   5F8
....................          else if (c == '-') 
05F2:  MOVF   3B,W
05F3:  SUBLW  2D
05F4:  BTFSS  03.2
05F5:  GOTO   5F8
....................          { 
....................             sign = 1; 
05F6:  BSF    3A.1
....................             continue; 
05F7:  GOTO   6B5
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
05F8:  BTFSC  3A.0
05F9:  GOTO   602
05FA:  MOVF   3B,W
05FB:  SUBLW  2E
05FC:  BTFSS  03.2
05FD:  GOTO   602
05FE:  BTFSC  3A.2
05FF:  GOTO   602
....................          point = 1; 
0600:  BSF    3A.2
0601:  GOTO   6B5
....................       else if (!skip && isdigit(c)) 
0602:  BTFSC  3A.0
0603:  GOTO   6B3
0604:  MOVF   3B,W
0605:  SUBLW  2F
0606:  BTFSC  03.0
0607:  GOTO   6B3
0608:  MOVF   3B,W
0609:  SUBLW  39
060A:  BTFSS  03.0
060B:  GOTO   6B3
....................       { 
....................          c -= '0'; 
060C:  MOVLW  30
060D:  SUBWF  3B,F
....................          if (point) 
060E:  BTFSS  3A.2
060F:  GOTO   66F
....................          { 
....................             pow10 = pow10 * 10.0; 
0610:  MOVF   35,W
0611:  MOVWF  52
0612:  MOVF   34,W
0613:  MOVWF  51
0614:  MOVF   33,W
0615:  MOVWF  50
0616:  MOVF   32,W
0617:  MOVWF  4F
0618:  CLRF   56
0619:  CLRF   55
061A:  MOVLW  20
061B:  MOVWF  54
061C:  MOVLW  82
061D:  MOVWF  53
061E:  BCF    03.5
061F:  CALL   404
0620:  MOVF   7A,W
0621:  BSF    03.5
0622:  MOVWF  35
0623:  MOVF   79,W
0624:  MOVWF  34
0625:  MOVF   78,W
0626:  MOVWF  33
0627:  MOVF   77,W
0628:  MOVWF  32
0629:  BCF    03.5
062A:  CLRF   27
062B:  BTFSC  0B.7
062C:  BSF    27.7
062D:  BCF    0B.7
....................             result += (float)c / pow10;    
062E:  BSF    03.5
062F:  CLRF   5D
0630:  MOVF   3B,W
0631:  MOVWF  5C
0632:  BCF    03.5
0633:  CALL   087
0634:  BTFSC  27.7
0635:  BSF    0B.7
0636:  MOVF   7A,W
0637:  BSF    03.5
0638:  MOVWF  40
0639:  MOVF   79,W
063A:  MOVWF  3F
063B:  MOVF   78,W
063C:  MOVWF  3E
063D:  MOVF   77,W
063E:  MOVWF  3D
063F:  MOVF   40,W
0640:  MOVWF  44
0641:  MOVF   3F,W
0642:  MOVWF  43
0643:  MOVF   3E,W
0644:  MOVWF  42
0645:  MOVF   3D,W
0646:  MOVWF  41
0647:  MOVF   35,W
0648:  MOVWF  48
0649:  MOVF   34,W
064A:  MOVWF  47
064B:  MOVF   33,W
064C:  MOVWF  46
064D:  MOVF   32,W
064E:  MOVWF  45
064F:  BCF    03.5
0650:  CALL   1C4
0651:  BCF    03.1
0652:  BSF    03.5
0653:  MOVF   39,W
0654:  MOVWF  44
0655:  MOVF   38,W
0656:  MOVWF  43
0657:  MOVF   37,W
0658:  MOVWF  42
0659:  MOVF   36,W
065A:  MOVWF  41
065B:  MOVF   7A,W
065C:  MOVWF  48
065D:  MOVF   79,W
065E:  MOVWF  47
065F:  MOVF   78,W
0660:  MOVWF  46
0661:  MOVF   77,W
0662:  MOVWF  45
0663:  BCF    03.5
0664:  CALL   47B
0665:  MOVF   7A,W
0666:  BSF    03.5
0667:  MOVWF  39
0668:  MOVF   79,W
0669:  MOVWF  38
066A:  MOVF   78,W
066B:  MOVWF  37
066C:  MOVF   77,W
066D:  MOVWF  36
....................          } 
066E:  GOTO   6B2
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
066F:  CLRF   52
0670:  CLRF   51
0671:  MOVLW  20
0672:  MOVWF  50
0673:  MOVLW  82
0674:  MOVWF  4F
0675:  MOVF   39,W
0676:  MOVWF  56
0677:  MOVF   38,W
0678:  MOVWF  55
0679:  MOVF   37,W
067A:  MOVWF  54
067B:  MOVF   36,W
067C:  MOVWF  53
067D:  BCF    03.5
067E:  CALL   404
067F:  MOVF   7A,W
0680:  BSF    03.5
0681:  MOVWF  40
0682:  MOVF   79,W
0683:  MOVWF  3F
0684:  MOVF   78,W
0685:  MOVWF  3E
0686:  MOVF   77,W
0687:  MOVWF  3D
0688:  BCF    03.5
0689:  CLRF   27
068A:  BTFSC  0B.7
068B:  BSF    27.7
068C:  BCF    0B.7
068D:  BSF    03.5
068E:  CLRF   5D
068F:  MOVF   3B,W
0690:  MOVWF  5C
0691:  BCF    03.5
0692:  CALL   087
0693:  BTFSC  27.7
0694:  BSF    0B.7
0695:  BCF    03.1
0696:  BSF    03.5
0697:  MOVF   40,W
0698:  MOVWF  44
0699:  MOVF   3F,W
069A:  MOVWF  43
069B:  MOVF   3E,W
069C:  MOVWF  42
069D:  MOVF   3D,W
069E:  MOVWF  41
069F:  MOVF   7A,W
06A0:  MOVWF  48
06A1:  MOVF   79,W
06A2:  MOVWF  47
06A3:  MOVF   78,W
06A4:  MOVWF  46
06A5:  MOVF   77,W
06A6:  MOVWF  45
06A7:  BCF    03.5
06A8:  CALL   47B
06A9:  MOVF   7A,W
06AA:  BSF    03.5
06AB:  MOVWF  39
06AC:  MOVF   79,W
06AD:  MOVWF  38
06AE:  MOVF   78,W
06AF:  MOVWF  37
06B0:  MOVF   77,W
06B1:  MOVWF  36
....................          } 
....................       } 
06B2:  GOTO   6B5
....................       else if (!skip) 
06B3:  BTFSS  3A.0
....................          break; 
06B4:  GOTO   6BF
06B5:  MOVF   3C,W
06B6:  INCF   3C,F
06B7:  ADDWF  2E,W
06B8:  MOVWF  04
06B9:  BCF    03.7
06BA:  BTFSC  2F.0
06BB:  BSF    03.7
06BC:  MOVF   00,W
06BD:  MOVWF  3B
06BE:  GOTO   5E1
....................    } 
....................  
....................    if (sign) 
06BF:  BTFSS  3A.1
06C0:  GOTO   6DA
....................       result = -1*result; 
06C1:  CLRF   52
06C2:  CLRF   51
06C3:  MOVLW  80
06C4:  MOVWF  50
06C5:  MOVLW  7F
06C6:  MOVWF  4F
06C7:  MOVF   39,W
06C8:  MOVWF  56
06C9:  MOVF   38,W
06CA:  MOVWF  55
06CB:  MOVF   37,W
06CC:  MOVWF  54
06CD:  MOVF   36,W
06CE:  MOVWF  53
06CF:  BCF    03.5
06D0:  CALL   404
06D1:  MOVF   7A,W
06D2:  BSF    03.5
06D3:  MOVWF  39
06D4:  MOVF   79,W
06D5:  MOVWF  38
06D6:  MOVF   78,W
06D7:  MOVWF  37
06D8:  MOVF   77,W
06D9:  MOVWF  36
....................        
....................    if(endptr) 
06DA:  MOVF   30,W
06DB:  IORWF  31,W
06DC:  BTFSC  03.2
06DD:  GOTO   6FB
....................    { 
....................       if (ptr) { 
06DE:  MOVF   3C,F
06DF:  BTFSC  03.2
06E0:  GOTO   6F0
....................          ptr--; 
06E1:  DECF   3C,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
06E2:  MOVF   30,W
06E3:  MOVWF  04
06E4:  BCF    03.7
06E5:  BTFSC  31.0
06E6:  BSF    03.7
06E7:  MOVF   3C,W
06E8:  ADDWF  2E,W
06E9:  MOVWF  00
06EA:  INCF   04,F
06EB:  MOVF   2F,W
06EC:  MOVWF  00
06ED:  BTFSC  03.0
06EE:  INCF   00,F
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
06EF:  GOTO   6FB
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
06F0:  MOVF   30,W
06F1:  MOVWF  04
06F2:  BCF    03.7
06F3:  BTFSC  31.0
06F4:  BSF    03.7
06F5:  INCF   04,F
06F6:  MOVF   2F,W
06F7:  MOVWF  00
06F8:  DECF   04,F
06F9:  MOVF   2E,W
06FA:  MOVWF  00
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
06FB:  MOVF   36,W
06FC:  MOVWF  77
06FD:  MOVF   37,W
06FE:  MOVWF  78
06FF:  MOVF   38,W
0700:  MOVWF  79
0701:  MOVF   39,W
0702:  MOVWF  7A
0703:  BCF    03.5
0704:  BSF    0A.3
0705:  BCF    0A.4
0706:  GOTO   354 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "LCD_I2C.c" 
.................... // flags for control 
.................... #define LCD_CLEARDISPLAY 0x01 
.................... #define LCD_RETURNHOME 0x02 
.................... #define LCD_ENTRYMODESET 0x04 
.................... #define LCD_DISPLAYCONTROL 0x08 
.................... #define LCD_CURSORSHIFT 0x10 
.................... #define LCD_FUNCTIONSET 0x20 
.................... #define LCD_SETCGRAMADDR 0x40 
.................... #define LCD_SETDDRAMADDR 0x80 
....................  
.................... // flags for display entry mode 
.................... #define LCD_ENTRYRIGHT 0x00 
.................... #define LCD_ENTRYLEFT 0x02 
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01 
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00 
....................  
....................  
.................... // flags for display on/off control 
.................... #define LCD_DISPLAYON 0x04 
.................... #define LCD_DISPLAYOFF 0x00 
.................... #define LCD_CURSORON 0x02 
.................... #define LCD_CURSOROFF 0x00 
.................... #define LCD_BLINKON 0x01 
.................... #define LCD_BLINKOFF 0x00 
....................  
.................... // flags for display/cursor shift 
.................... #define LCD_DISPLAYMOVE 0x08 
.................... #define LCD_CURSORMOVE 0x00 
.................... #define LCD_MOVERIGHT 0x04 
.................... #define LCD_MOVELEFT 0x00 
....................  
.................... // flags for function set 
.................... #define LCD_8BITMODE 0x10 
.................... #define LCD_4BITMODE 0x00 
.................... #define LCD_2LINE 0x08 
.................... #define LCD_1LINE 0x00 
.................... #define LCD_5x10DOTS 0x04 
.................... #define LCD_5x8DOTS 0x00 
....................  
.................... #define uint8_t unsigned int 
.................... #define uint16_t unsigned int16 
.................... // flags for backlight control 
.................... #define LCD_BACKLIGHT 0x08 
.................... #define LCD_NOBACKLIGHT 0x00 
....................  
.................... // function flags 
.................... #define En 0b00000100  // Enable bit 
.................... #define Rw 0b00000010  // Read/Write bit 
....................  
.................... uint8_t _address; 
.................... uint8_t _backlightVal = LCD_BACKLIGHT; 
.................... uint8_t _displayControl; 
.................... uint8_t _displayFunction; 
.................... uint8_t _displayMode; 
.................... uint8_t _rows; 
.................... uint8_t _columns; 
....................  
.................... // sends code to pcf8574 so it redirects to the display 
.................... void expanderWrite(uint8_t _data) { 
....................    I2C_Start(); 
*
0371:  BSF    28.4
0372:  MOVF   28,W
0373:  BSF    03.5
0374:  MOVWF  07
0375:  NOP
0376:  BCF    03.5
0377:  BSF    28.5
0378:  MOVF   28,W
0379:  BSF    03.5
037A:  MOVWF  07
037B:  NOP
037C:  BCF    03.5
037D:  BCF    07.4
037E:  BCF    28.4
037F:  MOVF   28,W
0380:  BSF    03.5
0381:  MOVWF  07
0382:  NOP
0383:  BCF    03.5
0384:  BCF    07.5
0385:  BCF    28.5
0386:  MOVF   28,W
0387:  BSF    03.5
0388:  MOVWF  07
....................    I2C_Write(_address); 
0389:  BCF    03.5
038A:  MOVF   2F,W
038B:  BSF    03.5
038C:  MOVWF  51
038D:  BCF    03.5
038E:  CALL   327
....................    // Always write the backlight val 
....................    I2C_Write((int)(_data) | _backlightval); 
038F:  BSF    03.5
0390:  MOVF   4F,W
0391:  BCF    03.5
0392:  IORWF  30,W
0393:  BSF    03.5
0394:  MOVWF  50
0395:  MOVWF  51
0396:  BCF    03.5
0397:  CALL   327
....................    I2C_stop(); 
0398:  BCF    28.4
0399:  MOVF   28,W
039A:  BSF    03.5
039B:  MOVWF  07
039C:  NOP
039D:  BCF    03.5
039E:  BSF    28.5
039F:  MOVF   28,W
03A0:  BSF    03.5
03A1:  MOVWF  07
03A2:  BCF    03.5
03A3:  BTFSS  07.5
03A4:  GOTO   3A3
03A5:  NOP
03A6:  GOTO   3A7
03A7:  NOP
03A8:  BSF    28.4
03A9:  MOVF   28,W
03AA:  BSF    03.5
03AB:  MOVWF  07
03AC:  NOP
03AD:  BCF    03.5
03AE:  RETURN
.................... } 
....................  
....................  
.................... // Pulse enable to write command 
.................... void pulseEnable(uint8_t _data) { 
....................    expanderWrite(_data | En); 
*
03B7:  MOVF   4D,W
03B8:  IORLW  04
03B9:  MOVWF  4E
03BA:  MOVWF  4F
03BB:  BCF    03.5
03BC:  CALL   371
....................    delay_us(1); 
03BD:  GOTO   3BE
03BE:  GOTO   3BF
03BF:  NOP
....................     
....................    expanderWrite(_data & ~En); 
03C0:  BSF    03.5
03C1:  MOVF   4D,W
03C2:  ANDLW  FB
03C3:  MOVWF  4E
03C4:  MOVWF  4F
03C5:  BCF    03.5
03C6:  CALL   371
....................    delay_us(50); 
03C7:  MOVLW  52
03C8:  MOVWF  77
03C9:  DECFSZ 77,F
03CA:  GOTO   3C9
03CB:  GOTO   3CC
03CC:  NOP
.................... } 
....................  
.................... // Send 4 bits to expander, than pulse enable 
.................... void write4bits(uint8_t value) { 
....................    expanderWrite(value); 
*
03AF:  BSF    03.5
03B0:  MOVF   4C,W
03B1:  MOVWF  4F
03B2:  BCF    03.5
03B3:  CALL   371
....................    pulseEnable(value); 
03B4:  BSF    03.5
03B5:  MOVF   4C,W
03B6:  MOVWF  4D
*
03CD:  RETURN
.................... } 
....................  
.................... // Send 8 bits dividing in two nibbles 
.................... void send(uint8_t value, uint8_t mode) { 
03CE:  BSF    03.5
03CF:  MOVF   47,W
03D0:  ANDLW  F0
03D1:  MOVWF  49
03D2:  SWAPF  47,W
03D3:  MOVWF  77
03D4:  MOVLW  F0
03D5:  ANDWF  77,F
03D6:  MOVF   77,W
03D7:  ANDLW  F0
03D8:  MOVWF  4A
....................    uint8_t MSB = value & 0b11110000; 
....................    uint8_t LSB = (value << 4) & 0b11110000; 
....................    write4bits((MSB)|mode); 
03D9:  MOVF   49,W
03DA:  IORWF  48,W
03DB:  MOVWF  4B
03DC:  MOVWF  4C
03DD:  BCF    03.5
03DE:  CALL   3AF
....................    write4bits((LSB)|mode); 
03DF:  BSF    03.5
03E0:  MOVF   4A,W
03E1:  IORWF  48,W
03E2:  MOVWF  4B
03E3:  MOVWF  4C
03E4:  BCF    03.5
03E5:  CALL   3AF
03E6:  RETURN
.................... } 
....................  
.................... // Command uses RS = 0 
.................... void command(uint8_t value) { 
....................    send(value, 0b00000000); 
03E7:  BSF    03.5
03E8:  MOVF   33,W
03E9:  MOVWF  47
03EA:  CLRF   48
03EB:  BCF    03.5
03EC:  CALL   3CE
03ED:  RETURN
.................... } 
....................  
.................... // Write uses RS = 1 
.................... int write(uint8_t value) { 
....................    send(value, 0b00000001); 
*
07A5:  MOVF   46,W
07A6:  MOVWF  47
07A7:  MOVLW  01
07A8:  MOVWF  48
07A9:  BCF    03.5
07AA:  CALL   3CE
....................    return 1; 
07AB:  MOVLW  01
07AC:  MOVWF  78
.................... } 
....................  
.................... // Change display configurations 
.................... void display() { 
....................    _displayControl |= LCD_DISPLAYON; 
*
0B17:  BSF    31.2
....................    command(LCD_DISPLAYCONTROL | _displayControl); 
0B18:  MOVF   31,W
0B19:  IORLW  08
0B1A:  BSF    03.5
0B1B:  MOVWF  31
0B1C:  MOVWF  33
0B1D:  BCF    0A.3
0B1E:  BCF    03.5
0B1F:  CALL   3E7
0B20:  BSF    0A.3
.................... } 
....................  
.................... // Clear display 
.................... void clear() { 
....................    command(LCD_CLEARDISPLAY); 
*
03EE:  MOVLW  01
03EF:  BSF    03.5
03F0:  MOVWF  33
03F1:  BCF    03.5
03F2:  CALL   3E7
....................    delay_us(2000); 
03F3:  MOVLW  02
03F4:  BSF    03.5
03F5:  MOVWF  32
03F6:  BCF    03.5
03F7:  CALL   313
03F8:  RETURN
.................... } 
....................  
.................... // Put cursor home 
.................... void home() { 
....................    command(LCD_RETURNHOME); 
03F9:  MOVLW  02
03FA:  BSF    03.5
03FB:  MOVWF  33
03FC:  BCF    03.5
03FD:  CALL   3E7
....................    delay_us(2000); 
03FE:  MOVLW  02
03FF:  BSF    03.5
0400:  MOVWF  32
0401:  BCF    03.5
0402:  CALL   313
0403:  RETURN
.................... } 
....................  
.................... // Put cursor on specified column/row 
.................... // PS: Rows and Columns start with 0 
.................... void setCursor(uint8_t col, uint8_t row){ 
....................    int row_offsets[] = { 0x00, 0x40 }; 
*
09D4:  BSF    03.5
09D5:  CLRF   30
09D6:  MOVLW  40
09D7:  MOVWF  31
09D8:  BCF    03.5
09D9:  CLRF   27
09DA:  BTFSC  0B.7
09DB:  BSF    27.7
09DC:  BCF    0B.7
....................    row = (row%_rows);     
09DD:  BSF    03.5
09DE:  MOVF   2F,W
09DF:  MOVWF  5C
09E0:  BCF    03.5
09E1:  MOVF   34,W
09E2:  BSF    03.5
09E3:  MOVWF  5D
09E4:  BCF    0A.3
09E5:  BCF    03.5
09E6:  CALL   03F
09E7:  BSF    0A.3
09E8:  BTFSC  27.7
09E9:  BSF    0B.7
09EA:  MOVF   77,W
09EB:  BSF    03.5
09EC:  MOVWF  2F
....................    command(LCD_SETDDRAMADDR | (col + row_offsets[row])); 
09ED:  MOVLW  B0
09EE:  ADDWF  2F,W
09EF:  MOVWF  04
09F0:  BCF    03.7
09F1:  MOVF   00,W
09F2:  ADDWF  2E,W
09F3:  IORLW  80
09F4:  MOVWF  32
09F5:  MOVWF  33
09F6:  BCF    0A.3
09F7:  BCF    03.5
09F8:  CALL   3E7
09F9:  BSF    0A.3
09FA:  BSF    0A.3
09FB:  BCF    0A.4
09FC:  GOTO   4D4 (RETURN)
.................... } 
....................  
....................  
.................... // Write an array of chars 
.................... void printstr(char c[]) { 
*
0790:  BSF    03.5
0791:  CLRF   44
....................    int i = 0; 
....................    while (c[i]) { 
0792:  MOVF   44,W
0793:  ADDWF  42,W
0794:  MOVWF  04
0795:  BCF    03.7
0796:  BTFSC  43.0
0797:  BSF    03.7
0798:  MOVF   00,F
0799:  BTFSC  03.2
079A:  GOTO   7B0
....................       write(c[i]); 
079B:  MOVF   44,W
079C:  ADDWF  42,W
079D:  MOVWF  04
079E:  BCF    03.7
079F:  BTFSC  43.0
07A0:  BSF    03.7
07A1:  MOVF   00,W
07A2:  MOVWF  45
07A3:  MOVF   45,W
07A4:  MOVWF  46
....................       i++; 
*
07AD:  BSF    03.5
07AE:  INCF   44,F
07AF:  GOTO   792
....................    } 
07B0:  BCF    03.5
07B1:  RETURN
.................... } 
....................  
.................... // print single int 
.................... void printint(uint16_t d) { 
....................     char c[16]; 
....................     sprintf(c, "%lu", d); 
....................     printstr(c); 
.................... } 
....................  
.................... // print long in form 00X -> XXX 
.................... void printlong(uint16_t d) { 
....................     char c[16]; 
....................     sprintf(c, "%04lu", d); 
....................     printstr(c); 
.................... } 
....................  
.................... // print float xxxx.xxx 
.................... void printfloat(float f) { 
....................     char c[16]; 
....................     sprintf(c, "%.2f\xDFC", f); 
*
07C1:  CLRF   37
07C2:  MOVLW  B2
07C3:  MOVWF  36
07C4:  MOVLW  89
07C5:  MOVWF  04
07C6:  BSF    03.5
07C7:  MOVF   31,W
07C8:  MOVWF  45
07C9:  MOVF   30,W
07CA:  MOVWF  44
07CB:  MOVF   2F,W
07CC:  MOVWF  43
07CD:  MOVF   2E,W
07CE:  MOVWF  42
07CF:  MOVLW  02
07D0:  MOVWF  46
07D1:  BSF    0A.3
07D2:  BCF    03.5
07D3:  GOTO   0E9
07D4:  BCF    0A.3
07D5:  MOVLW  DF
07D6:  BSF    03.5
07D7:  MOVWF  4F
07D8:  BCF    03.5
07D9:  CALL   7B2
07DA:  MOVLW  43
07DB:  BSF    03.5
07DC:  MOVWF  4F
07DD:  BCF    03.5
07DE:  CALL   7B2
....................     printstr(c); 
07DF:  BSF    03.5
07E0:  CLRF   43
07E1:  MOVLW  B2
07E2:  MOVWF  42
07E3:  BCF    03.5
07E4:  CALL   790
07E5:  RETURN
.................... } 
....................  
.................... // Automatic display configuration 
.................... void initializeLCD(uint8_t address, uint8_t columns, uint8_t rows) { 
....................    _address = address; 
*
0A8E:  MOVF   2E,W
0A8F:  BCF    03.5
0A90:  MOVWF  2F
....................    _columns = columns; 
0A91:  BSF    03.5
0A92:  MOVF   2F,W
0A93:  BCF    03.5
0A94:  MOVWF  35
....................    _rows = rows; 
0A95:  BSF    03.5
0A96:  MOVF   30,W
0A97:  BCF    03.5
0A98:  MOVWF  34
....................     
....................    _displayFunction = LCD_4BITMODE | LCD_2LINE | LCD_5x8DOTS; 
0A99:  MOVLW  08
0A9A:  MOVWF  32
....................    delay_ms(500); 
0A9B:  MOVLW  02
0A9C:  BSF    03.5
0A9D:  MOVWF  31
0A9E:  MOVLW  FA
0A9F:  MOVWF  32
0AA0:  BCF    0A.3
0AA1:  BCF    03.5
0AA2:  CALL   313
0AA3:  BSF    0A.3
0AA4:  BSF    03.5
0AA5:  DECFSZ 31,F
0AA6:  GOTO   29E
....................    expanderWrite(_backlightval); 
0AA7:  BCF    03.5
0AA8:  MOVF   30,W
0AA9:  BSF    03.5
0AAA:  MOVWF  4F
0AAB:  BCF    0A.3
0AAC:  BCF    03.5
0AAD:  CALL   371
0AAE:  BSF    0A.3
....................    delay_ms(1000); 
0AAF:  MOVLW  04
0AB0:  BSF    03.5
0AB1:  MOVWF  31
0AB2:  MOVLW  FA
0AB3:  MOVWF  32
0AB4:  BCF    0A.3
0AB5:  BCF    03.5
0AB6:  CALL   313
0AB7:  BSF    0A.3
0AB8:  BSF    03.5
0AB9:  DECFSZ 31,F
0ABA:  GOTO   2B2
....................     
....................    write4bits(0x03 << 4); 
0ABB:  MOVLW  30
0ABC:  MOVWF  4C
0ABD:  BCF    0A.3
0ABE:  BCF    03.5
0ABF:  CALL   3AF
0AC0:  BSF    0A.3
....................    delay_us(4500); 
0AC1:  MOVLW  04
0AC2:  BSF    03.5
0AC3:  MOVWF  32
0AC4:  BCF    0A.3
0AC5:  BCF    03.5
0AC6:  CALL   313
0AC7:  BSF    0A.3
0AC8:  MOVLW  02
0AC9:  BSF    03.5
0ACA:  MOVWF  31
0ACB:  MOVLW  F9
0ACC:  MOVWF  38
0ACD:  BCF    0A.3
0ACE:  BCF    03.5
0ACF:  CALL   141
0AD0:  BSF    0A.3
0AD1:  BSF    03.5
0AD2:  DECFSZ 31,F
0AD3:  GOTO   2CB
....................     
....................    write4bits(0x03 << 4); 
0AD4:  MOVLW  30
0AD5:  MOVWF  4C
0AD6:  BCF    0A.3
0AD7:  BCF    03.5
0AD8:  CALL   3AF
0AD9:  BSF    0A.3
....................    delay_us(4500); 
0ADA:  MOVLW  04
0ADB:  BSF    03.5
0ADC:  MOVWF  32
0ADD:  BCF    0A.3
0ADE:  BCF    03.5
0ADF:  CALL   313
0AE0:  BSF    0A.3
0AE1:  MOVLW  02
0AE2:  BSF    03.5
0AE3:  MOVWF  31
0AE4:  MOVLW  F9
0AE5:  MOVWF  38
0AE6:  BCF    0A.3
0AE7:  BCF    03.5
0AE8:  CALL   141
0AE9:  BSF    0A.3
0AEA:  BSF    03.5
0AEB:  DECFSZ 31,F
0AEC:  GOTO   2E4
....................     
....................    write4bits(0x03 << 4); 
0AED:  MOVLW  30
0AEE:  MOVWF  4C
0AEF:  BCF    0A.3
0AF0:  BCF    03.5
0AF1:  CALL   3AF
0AF2:  BSF    0A.3
....................    delay_us(1500); 
0AF3:  MOVLW  01
0AF4:  BSF    03.5
0AF5:  MOVWF  32
0AF6:  BCF    0A.3
0AF7:  BCF    03.5
0AF8:  CALL   313
0AF9:  BSF    0A.3
0AFA:  MOVLW  02
0AFB:  BSF    03.5
0AFC:  MOVWF  31
0AFD:  MOVLW  F9
0AFE:  MOVWF  38
0AFF:  BCF    0A.3
0B00:  BCF    03.5
0B01:  CALL   141
0B02:  BSF    0A.3
0B03:  BSF    03.5
0B04:  DECFSZ 31,F
0B05:  GOTO   2FD
....................     
....................    write4bits(0x02 << 4); 
0B06:  MOVLW  20
0B07:  MOVWF  4C
0B08:  BCF    0A.3
0B09:  BCF    03.5
0B0A:  CALL   3AF
0B0B:  BSF    0A.3
....................     
....................    command(LCD_FUNCTIONSET | _displayFunction); 
0B0C:  MOVF   32,W
0B0D:  IORLW  20
0B0E:  BSF    03.5
0B0F:  MOVWF  31
0B10:  MOVWF  33
0B11:  BCF    0A.3
0B12:  BCF    03.5
0B13:  CALL   3E7
0B14:  BSF    0A.3
....................     
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSORON | LCD_BLINKON; 
0B15:  MOVLW  07
0B16:  MOVWF  31
....................     
....................    display(); 
....................     
....................    clear(); 
*
0B21:  BCF    0A.3
0B22:  CALL   3EE
0B23:  BSF    0A.3
....................     
....................    _displayMode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT; 
0B24:  MOVLW  02
0B25:  MOVWF  33
....................     
....................    command(LCD_ENTRYMODESET | _displayMode); 
0B26:  MOVF   33,W
0B27:  IORLW  04
0B28:  BSF    03.5
0B29:  MOVWF  31
0B2A:  MOVWF  33
0B2B:  BCF    0A.3
0B2C:  BCF    03.5
0B2D:  CALL   3E7
0B2E:  BSF    0A.3
....................     
....................    home(); 
0B2F:  BCF    0A.3
0B30:  CALL   3F9
0B31:  BSF    0A.3
.................... } 
....................  
....................  
....................  
.................... #include "sensor_temperatura.c" 
.................... // (C) copyright 2003 j.d.sandoz / jds-pic !at! losdos.dyndns.org  
....................  
.................... // released under the GNU GENERAL PUBLIC LICENSE (GPL)  
.................... // refer to http://www.gnu.org/licenses/gpl.txt  
....................  
.................... // This program is free software; you can redistribute it and/or modify  
.................... // it under the terms of the GNU General Public License as published by  
.................... // the Free Software Foundation; either version 2 of the License, or  
.................... // (at your option) any later version.  
....................  
.................... // This program is distributed in the hope that it will be useful,  
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of  
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
.................... // GNU General Public License for more details.  
....................  
.................... // You should have received a copy of the GNU General Public License  
.................... // along with this program; if not, write to the Free Software  
.................... // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA  
....................  
.................... /***********************1Wire Class***********************/  
.................... /*Description: This class handles all communication */  
.................... /* between the processor and the 1wire */  
.................... /* sensors.  
.................... /*********************************************************/  
....................  
.................... /*-------1-wire definitions-------*/  
.................... #define ONE_WIRE_PIN PIN_B1  
....................  
.................... /*******************1-wire communication functions********************/  
....................  
.................... /************onewire_reset*************************************************/  
.................... /*This function initiates the 1wire bus */  
.................... /* */  
.................... /*PARAMETERS: */  
.................... /*RETURNS: */  
.................... /*********************************************************************/  
....................  
.................... void onewire_reset()  // OK if just using a single permanently connected device  
.................... {  
....................  output_low(ONE_WIRE_PIN);  
*
0152:  BSF    03.5
0153:  BCF    06.1
0154:  BCF    03.5
0155:  BCF    06.1
....................  delay_us( 500 ); // pull 1-wire low for reset pulse  
0156:  MOVLW  02
0157:  BSF    03.5
0158:  MOVWF  37
0159:  MOVLW  F9
015A:  MOVWF  38
015B:  BCF    03.5
015C:  CALL   141
015D:  BSF    03.5
015E:  DECFSZ 37,F
015F:  GOTO   159
....................  output_float(ONE_WIRE_PIN); // float 1-wire high  
0160:  BSF    06.1
....................  delay_us( 500 ); // wait-out remaining initialisation window.  
0161:  MOVLW  02
0162:  MOVWF  37
0163:  MOVLW  F9
0164:  MOVWF  38
0165:  BCF    03.5
0166:  CALL   141
0167:  BSF    03.5
0168:  DECFSZ 37,F
0169:  GOTO   163
....................  output_float(ONE_WIRE_PIN);  
016A:  BSF    06.1
016B:  BCF    03.5
016C:  RETURN
.................... }  
....................  
.................... /*********************** onewire_write() ********************************/  
.................... /*This function writes a byte to the sensor.*/  
.................... /* */  
.................... /*Parameters: byte - the byte to be written to the 1-wire */  
.................... /*Returns: */  
.................... /*********************************************************************/  
....................  
.................... void onewire_write(int data)  
.................... {  
....................  int count;  
....................  
....................  for (count=0; count<8; ++count)  
016D:  BSF    03.5
016E:  CLRF   38
016F:  MOVF   38,W
0170:  SUBLW  07
0171:  BTFSS  03.0
0172:  GOTO   197
....................  {  
....................   output_low(ONE_WIRE_PIN);  
0173:  BCF    06.1
0174:  BCF    03.5
0175:  BCF    06.1
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot.  
0176:  MOVLW  02
0177:  MOVWF  77
0178:  DECFSZ 77,F
0179:  GOTO   178
017A:  GOTO   17B
017B:  NOP
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire  
017C:  BCF    03.0
017D:  BSF    03.5
017E:  RRF    37,F
017F:  BTFSC  03.0
0180:  GOTO   185
0181:  BCF    03.5
0182:  BCF    06.1
0183:  GOTO   187
0184:  BSF    03.5
0185:  BCF    03.5
0186:  BSF    06.1
0187:  BSF    03.5
0188:  BCF    06.1
....................   delay_us( 60 ); // wait until end of write slot.  
0189:  MOVLW  63
018A:  MOVWF  77
018B:  DECFSZ 77,F
018C:  GOTO   18B
018D:  GOTO   18E
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again,  
018E:  BSF    06.1
....................   delay_us( 2 ); // for more than 1us minimum.  
018F:  MOVLW  02
0190:  MOVWF  77
0191:  DECFSZ 77,F
0192:  GOTO   191
0193:  GOTO   194
0194:  NOP
0195:  INCF   38,F
0196:  GOTO   16F
....................  }  
0197:  BCF    03.5
0198:  RETURN
.................... }  
....................  
.................... /*********************** read1wire() *********************************/  
.................... /*This function reads the 8 -bit data via the 1-wire sensor. */  
.................... /* */  
.................... /*Parameters: */  
.................... /*Returns: 8-bit (1-byte) data from sensor */  
.................... /*********************************************************************/  
....................  
.................... int onewire_read()  
.................... {  
....................  int count, data;  
....................  
....................  for (count=0; count<8; ++count)  
0199:  BSF    03.5
019A:  CLRF   37
019B:  MOVF   37,W
019C:  SUBLW  07
019D:  BTFSS  03.0
019E:  GOTO   1C0
....................  {  
....................   output_low(ONE_WIRE_PIN);  
019F:  BCF    06.1
01A0:  BCF    03.5
01A1:  BCF    06.1
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot.  
01A2:  MOVLW  02
01A3:  MOVWF  77
01A4:  DECFSZ 77,F
01A5:  GOTO   1A4
01A6:  GOTO   1A7
01A7:  NOP
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high,  
01A8:  BSF    03.5
01A9:  BSF    06.1
....................   delay_us( 8 ); // let device state stabilise,  
01AA:  MOVLW  0C
01AB:  MOVWF  77
01AC:  DECFSZ 77,F
01AD:  GOTO   1AC
01AE:  GOTO   1AF
01AF:  NOP
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result.  
01B0:  BSF    06.1
01B1:  BCF    03.5
01B2:  BTFSC  06.1
01B3:  GOTO   1B6
01B4:  BCF    03.0
01B5:  GOTO   1B7
01B6:  BSF    03.0
01B7:  BSF    03.5
01B8:  RRF    38,F
....................   delay_us( 120 ); // wait until end of read slot.  
01B9:  MOVLW  C7
01BA:  MOVWF  77
01BB:  DECFSZ 77,F
01BC:  GOTO   1BB
01BD:  GOTO   1BE
01BE:  INCF   37,F
01BF:  GOTO   19B
....................  }  
....................  
....................  return( data );  
01C0:  MOVF   38,W
01C1:  MOVWF  78
01C2:  BCF    03.5
01C3:  RETURN
.................... }  
....................  
.................... float ds1820_read()  
*
0290:  BSF    03.5
0291:  CLRF   2E
.................... {  
....................  int8 busy=0, temp1, temp2;  
....................  signed int16 temp3;  
....................  float result;  
....................  
....................  onewire_reset();  
0292:  BCF    03.5
0293:  CALL   152
....................  onewire_write(0xCC);  
0294:  MOVLW  CC
0295:  BSF    03.5
0296:  MOVWF  37
0297:  BCF    03.5
0298:  CALL   16D
....................  onewire_write(0x44);  
0299:  MOVLW  44
029A:  BSF    03.5
029B:  MOVWF  37
029C:  BCF    03.5
029D:  CALL   16D
....................  
....................  while (busy == 0)  
029E:  BSF    03.5
029F:  MOVF   2E,F
02A0:  BTFSS  03.2
02A1:  GOTO   2A8
....................   busy = onewire_read();  
02A2:  BCF    03.5
02A3:  CALL   199
02A4:  MOVF   78,W
02A5:  BSF    03.5
02A6:  MOVWF  2E
02A7:  GOTO   29F
....................  
....................  onewire_reset();  
02A8:  BCF    03.5
02A9:  CALL   152
....................  onewire_write(0xCC);  
02AA:  MOVLW  CC
02AB:  BSF    03.5
02AC:  MOVWF  37
02AD:  BCF    03.5
02AE:  CALL   16D
....................  onewire_write(0xBE);  
02AF:  MOVLW  BE
02B0:  BSF    03.5
02B1:  MOVWF  37
02B2:  BCF    03.5
02B3:  CALL   16D
....................  temp1 = onewire_read();  
02B4:  CALL   199
02B5:  MOVF   78,W
02B6:  BSF    03.5
02B7:  MOVWF  2F
....................  temp2 = onewire_read();  
02B8:  BCF    03.5
02B9:  CALL   199
02BA:  MOVF   78,W
02BB:  BSF    03.5
02BC:  MOVWF  30
....................  temp3 = make16(temp2, temp1);  
02BD:  MOVF   30,W
02BE:  MOVWF  32
02BF:  MOVF   2F,W
02C0:  MOVWF  31
....................    
....................  // result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution  
.................... result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution  
02C1:  MOVF   32,W
02C2:  MOVWF  38
02C3:  MOVF   31,W
02C4:  MOVWF  37
*
02E9:  MOVF   7A,W
02EA:  MOVWF  3A
02EB:  MOVF   79,W
02EC:  MOVWF  39
02ED:  MOVF   78,W
02EE:  MOVWF  38
02EF:  MOVF   77,W
02F0:  MOVWF  37
02F1:  MOVF   3A,W
02F2:  MOVWF  44
02F3:  MOVF   39,W
02F4:  MOVWF  43
02F5:  MOVF   38,W
02F6:  MOVWF  42
02F7:  MOVF   37,W
02F8:  MOVWF  41
02F9:  CLRF   48
02FA:  CLRF   47
02FB:  CLRF   46
02FC:  MOVLW  83
02FD:  MOVWF  45
02FE:  BCF    03.5
02FF:  CALL   1C4
0300:  MOVF   7A,W
0301:  BSF    03.5
0302:  MOVWF  36
0303:  MOVF   79,W
0304:  MOVWF  35
0305:  MOVF   78,W
0306:  MOVWF  34
0307:  MOVF   77,W
0308:  MOVWF  33
....................    
....................  //for (int32 i = 0; i < 100000; ++i);//Delay 
....................   
....................  return(result);  
0309:  MOVF   33,W
030A:  MOVWF  77
030B:  MOVF   34,W
030C:  MOVWF  78
030D:  MOVF   35,W
030E:  MOVWF  79
030F:  MOVF   36,W
0310:  MOVWF  7A
0311:  BCF    03.5
0312:  RETURN
.................... }  
....................  
....................  
.................... #define LCD_ADDR 0x4E 
....................  
.................... //PIN_B0 -> Detecta passagem por 0 
.................... //PIN_B1 -> Sensor de temperatura 
.................... //PIN_B2 -> Ativa a resistencia 
....................  
....................  
.................... //Temperatura 
.................... float y = 35.0f; //   Temperatura atual 
.................... float r = 35.0f; //   setPoint 
....................  
.................... float u_atual = 0; 
.................... float u_anterior = 0; 
.................... float e_atual = 0; 
.................... float e_anterior = 0; 
.................... const float Kp = 1/0.9; 
.................... const float Ti = 10.33f; 
.................... const float T  = 1; 
....................  
....................  
.................... //Timers 
.................... int overflowCount = 0; 
.................... int1 umSegundo = FALSE; 
.................... int1 meioSegundo = FALSE; 
.................... int1 umQuartoSegundo = FALSE; 
.................... int1 umOitavoSegundo = FALSE; 
....................  
.................... //Action 
.................... int ticks = 0; 
....................  
.................... //Comunicacao 
.................... #define BUFF_LEN 30  
.................... char string[BUFF_LEN];  
.................... int1 have_string=FALSE;  
....................  
....................  
.................... #INT_RTCC 
.................... void  RTCC_isr(void)  
.................... { 
....................    overflowCount++; 
*
0056:  INCF   50,F
....................     
....................    if (overflowCount % 9 == 0) 
0057:  MOVF   50,W
0058:  BSF    03.5
0059:  MOVWF  5C
005A:  MOVLW  09
005B:  MOVWF  5D
005C:  BCF    03.5
005D:  CALL   03F
005E:  MOVF   77,F
005F:  BTFSC  03.2
....................       umOitavoSegundo = TRUE;    
0060:  BSF    51.3
....................        
....................    if (overflowCount % 19 == 0) 
0061:  MOVF   50,W
0062:  BSF    03.5
0063:  MOVWF  5C
0064:  MOVLW  13
0065:  MOVWF  5D
0066:  BCF    03.5
0067:  CALL   03F
0068:  MOVF   77,F
0069:  BTFSC  03.2
....................       umQuartoSegundo = TRUE; 
006A:  BSF    51.2
....................     
....................    if (overflowCount % 38 == 0) 
006B:  MOVF   50,W
006C:  BSF    03.5
006D:  MOVWF  5C
006E:  MOVLW  26
006F:  MOVWF  5D
0070:  BCF    03.5
0071:  CALL   03F
0072:  MOVF   77,F
0073:  BTFSC  03.2
....................       meioSegundo = TRUE; 
0074:  BSF    51.1
....................        
....................    if (overflowCount % 76 == 0) 
0075:  MOVF   50,W
0076:  BSF    03.5
0077:  MOVWF  5C
0078:  MOVLW  4C
0079:  MOVWF  5D
007A:  BCF    03.5
007B:  CALL   03F
007C:  MOVF   77,F
007D:  BTFSC  03.2
....................       umSegundo = TRUE; 
007E:  BSF    51.0
....................        
....................       
....................    if (overflowCount >= 76) overflowCount = 0;//Por seguranca 
007F:  MOVF   50,W
0080:  SUBLW  4B
0081:  BTFSS  03.0
0082:  CLRF   50
.................... } 
....................  
0083:  BCF    0B.2
0084:  BCF    0A.3
0085:  BCF    0A.4
0086:  GOTO   025
.................... #INT_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................    ticks++; 
*
00E7:  INCF   52,F
....................     
....................    if (u_atual > ticks) 
00E8:  BSF    03.5
00E9:  CLRF   5D
00EA:  BCF    03.5
00EB:  MOVF   52,W
00EC:  BSF    03.5
00ED:  MOVWF  5C
00EE:  BCF    03.5
00EF:  CALL   087
00F0:  MOVF   7A,W
00F1:  BSF    03.5
00F2:  MOVWF  5F
00F3:  MOVF   79,W
00F4:  MOVWF  5E
00F5:  MOVF   78,W
00F6:  MOVWF  5D
00F7:  MOVF   77,W
00F8:  MOVWF  5C
00F9:  BCF    03.5
00FA:  MOVF   43,W
00FB:  BSF    03.5
00FC:  MOVWF  63
00FD:  BCF    03.5
00FE:  MOVF   42,W
00FF:  BSF    03.5
0100:  MOVWF  62
0101:  BCF    03.5
0102:  MOVF   41,W
0103:  BSF    03.5
0104:  MOVWF  61
0105:  BCF    03.5
0106:  MOVF   40,W
0107:  BSF    03.5
0108:  MOVWF  60
0109:  BCF    03.5
010A:  CALL   0A6
010B:  BTFSS  03.0
010C:  GOTO   112
....................       output_high(PIN_B2); 
010D:  BSF    03.5
010E:  BCF    06.2
010F:  BCF    03.5
0110:  BSF    06.2
0111:  GOTO   116
....................    else 
....................       output_low(PIN_B2); 
0112:  BSF    03.5
0113:  BCF    06.2
0114:  BCF    03.5
0115:  BCF    06.2
....................     
....................    if (ticks > 60) 
0116:  MOVF   52,W
0117:  SUBLW  3C
0118:  BTFSS  03.0
....................       ticks = 0; 
0119:  CLRF   52
.................... } 
....................  
011A:  BCF    0B.1
011B:  BCF    0A.3
011C:  BCF    0A.4
011D:  GOTO   025
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................     static int ctr=0;  
....................     int ch;  
....................     ch=getc();  
011E:  BTFSS  0C.5
011F:  GOTO   11E
0120:  MOVF   1A,W
0121:  BSF    03.5
0122:  MOVWF  5C
....................     if (ch=='\n')  
0123:  MOVF   5C,W
0124:  SUBLW  0A
0125:  BTFSS  03.2
0126:  GOTO   131
....................     {  
....................         string[ctr]='\0';  
0127:  MOVLW  53
0128:  ADDWF  71,W
0129:  MOVWF  04
012A:  BCF    03.7
012B:  CLRF   00
....................         ctr=0;  
012C:  CLRF   71
....................         have_string=TRUE;  
012D:  BCF    03.5
012E:  BSF    51.4
....................         return;  
012F:  GOTO   13D
0130:  BSF    03.5
....................     }  
....................     string[ctr++]=ch;  
0131:  MOVF   71,W
0132:  INCF   71,F
0133:  ADDLW  53
0134:  MOVWF  04
0135:  BCF    03.7
0136:  MOVF   5C,W
0137:  MOVWF  00
....................     if (ctr==BUFF_LEN)  
0138:  MOVF   71,W
0139:  SUBLW  1E
013A:  BTFSC  03.2
....................         ctr--; //throw away characters if buffer overflows  
013B:  DECF   71,F
013C:  BCF    03.5
013D:  BCF    0C.5
013E:  BCF    0A.3
013F:  BCF    0A.4
0140:  GOTO   025
.................... } 
....................  
.................... void resetTimes() 
.................... { 
....................    disable_interrupts(INT_RTCC); 
*
07E6:  BCF    0B.5
....................     
....................    umSegundo = FALSE; 
07E7:  BCF    51.0
....................    meioSegundo = FALSE; 
07E8:  BCF    51.1
....................    umQuartoSegundo = FALSE; 
07E9:  BCF    51.2
....................    umOitavoSegundo = FALSE;   
07EA:  BCF    51.3
....................     
....................    enable_interrupts(INT_RTCC); 
07EB:  BSF    0B.5
07EC:  BSF    0A.3
07ED:  BCF    0A.4
07EE:  GOTO   4F1 (RETURN)
.................... } 
....................  
.................... void main() 
*
09FD:  MOVF   03,W
09FE:  ANDLW  1F
09FF:  MOVWF  03
0A00:  MOVLW  81
0A01:  BSF    03.5
0A02:  MOVWF  19
0A03:  MOVLW  E6
0A04:  MOVWF  18
0A05:  MOVLW  D0
0A06:  BCF    03.5
0A07:  MOVWF  18
0A08:  MOVLW  FF
0A09:  MOVWF  28
0A0A:  MOVLW  08
0A0B:  MOVWF  30
0A0C:  CLRF   37
0A0D:  CLRF   36
0A0E:  CLRF   3B
0A0F:  CLRF   3A
0A10:  MOVLW  0C
0A11:  MOVWF  39
0A12:  MOVLW  84
0A13:  MOVWF  38
0A14:  CLRF   3F
0A15:  CLRF   3E
0A16:  MOVLW  0C
0A17:  MOVWF  3D
0A18:  MOVLW  84
0A19:  MOVWF  3C
0A1A:  CLRF   43
0A1B:  CLRF   42
0A1C:  CLRF   41
0A1D:  CLRF   40
0A1E:  CLRF   47
0A1F:  CLRF   46
0A20:  CLRF   45
0A21:  CLRF   44
0A22:  CLRF   4B
0A23:  CLRF   4A
0A24:  CLRF   49
0A25:  CLRF   48
0A26:  CLRF   4F
0A27:  CLRF   4E
0A28:  CLRF   4D
0A29:  CLRF   4C
0A2A:  CLRF   50
0A2B:  BCF    51.0
0A2C:  BCF    51.1
0A2D:  BCF    51.2
0A2E:  BCF    51.3
0A2F:  CLRF   52
0A30:  BCF    51.4
0A31:  CLRF   71
0A32:  BSF    03.5
0A33:  BSF    1F.0
0A34:  BSF    1F.1
0A35:  BSF    1F.2
0A36:  BCF    1F.3
0A37:  MOVLW  07
0A38:  MOVWF  1C
0A39:  BCF    03.7
.................... { 
....................    setup_adc_ports(AN0); 
*
0A58:  BCF    1F.0
0A59:  BSF    1F.1
0A5A:  BSF    1F.2
0A5B:  BSF    1F.3
....................    setup_adc(ADC_CLOCK_DIV_2); 
0A5C:  BCF    1F.6
0A5D:  BCF    03.5
0A5E:  BCF    1F.6
0A5F:  BCF    1F.7
0A60:  BSF    03.5
0A61:  BSF    1F.7
0A62:  BCF    03.5
0A63:  BSF    1F.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256|RTCC_8_bit);      //13.1 ms overflow 
0A64:  BSF    03.5
0A65:  MOVF   01,W
0A66:  ANDLW  C0
0A67:  IORLW  07
0A68:  MOVWF  01
....................     
....................    enable_interrupts(INT_RTCC); 
0A69:  BCF    03.5
0A6A:  BSF    0B.5
....................    enable_interrupts(INT_EXT); 
0A6B:  BSF    0B.4
....................    enable_interrupts(INT_RDA); 
0A6C:  BSF    03.5
0A6D:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
0A6E:  MOVLW  C0
0A6F:  BCF    03.5
0A70:  IORWF  0B,F
....................     
....................    y = ds1820_read(); 
0A71:  BCF    0A.3
0A72:  CALL   290
0A73:  BSF    0A.3
0A74:  MOVF   7A,W
0A75:  MOVWF  3B
0A76:  MOVF   79,W
0A77:  MOVWF  3A
0A78:  MOVF   78,W
0A79:  MOVWF  39
0A7A:  MOVF   77,W
0A7B:  MOVWF  38
....................    delay_ms(1000); 
0A7C:  MOVLW  04
0A7D:  BSF    03.5
0A7E:  MOVWF  2E
0A7F:  MOVLW  FA
0A80:  MOVWF  32
0A81:  BCF    0A.3
0A82:  BCF    03.5
0A83:  CALL   313
0A84:  BSF    0A.3
0A85:  BSF    03.5
0A86:  DECFSZ 2E,F
0A87:  GOTO   27F
....................    initializeLCD(LCD_ADDR, 16, 2); 
0A88:  MOVLW  4E
0A89:  MOVWF  2E
0A8A:  MOVLW  10
0A8B:  MOVWF  2F
0A8C:  MOVLW  02
0A8D:  MOVWF  30
....................  
....................    while(TRUE) 
....................    { 
....................        if (umSegundo) 
*
0B32:  BTFSS  51.0
0B33:  GOTO   346
....................        {  
....................             y = ds1820_read();    
0B34:  BCF    0A.3
0B35:  CALL   290
0B36:  BSF    0A.3
0B37:  MOVF   7A,W
0B38:  MOVWF  3B
0B39:  MOVF   79,W
0B3A:  MOVWF  3A
0B3B:  MOVF   78,W
0B3C:  MOVWF  39
0B3D:  MOVF   77,W
0B3E:  MOVWF  38
....................             delay_ms(15); 
0B3F:  MOVLW  0F
0B40:  BSF    03.5
0B41:  MOVWF  32
0B42:  BCF    0A.3
0B43:  BCF    03.5
0B44:  CALL   313
0B45:  BSF    0A.3
....................        } 
....................     
....................        if (umOitavoSegundo)  
0B46:  BTFSS  51.3
0B47:  GOTO   3A6
....................        {  
....................             if (have_string) 
0B48:  BTFSS  51.4
0B49:  GOTO   35E
....................             { 
....................                have_string=FALSE;  
0B4A:  BCF    51.4
....................                //setCursor(0, 1); 
....................                r = atof(string);   
0B4B:  BSF    03.5
0B4C:  CLRF   2F
0B4D:  MOVLW  53
0B4E:  MOVWF  2E
0B4F:  CLRF   31
0B50:  CLRF   30
0B51:  BCF    0A.3
0B52:  BCF    03.5
0B53:  GOTO   5C1
0B54:  BSF    0A.3
0B55:  MOVF   7A,W
0B56:  MOVWF  3F
0B57:  MOVF   79,W
0B58:  MOVWF  3E
0B59:  MOVF   78,W
0B5A:  MOVWF  3D
0B5B:  MOVF   77,W
0B5C:  MOVWF  3C
....................                //printfloat(r); 
....................             }    
0B5D:  GOTO   3A6
....................             else 
....................             {            
....................                 if (umOitavoSegundo) 
0B5E:  BTFSS  51.3
0B5F:  GOTO   3A6
....................                 { 
....................                     fprintf(PORT1, "t%lf\n", y); 
0B60:  MOVLW  74
0B61:  BSF    03.5
0B62:  MOVWF  3B
0B63:  BCF    0A.3
0B64:  BCF    03.5
0B65:  CALL   707
0B66:  BSF    0A.3
0B67:  MOVLW  89
0B68:  MOVWF  04
0B69:  MOVF   3B,W
0B6A:  BSF    03.5
0B6B:  MOVWF  31
0B6C:  BCF    03.5
0B6D:  MOVF   3A,W
0B6E:  BSF    03.5
0B6F:  MOVWF  30
0B70:  BCF    03.5
0B71:  MOVF   39,W
0B72:  BSF    03.5
0B73:  MOVWF  2F
0B74:  BCF    03.5
0B75:  MOVF   38,W
0B76:  BSF    03.5
0B77:  MOVWF  2E
0B78:  MOVLW  02
0B79:  MOVWF  32
0B7A:  BCF    03.5
0B7B:  CALL   000
0B7C:  MOVLW  0A
0B7D:  BSF    03.5
0B7E:  MOVWF  3B
0B7F:  BCF    0A.3
0B80:  BCF    03.5
0B81:  CALL   707
0B82:  BSF    0A.3
....................                     fprintf(PORT1, "u%lf\n", u_atual); 
0B83:  MOVLW  75
0B84:  BSF    03.5
0B85:  MOVWF  3B
0B86:  BCF    0A.3
0B87:  BCF    03.5
0B88:  CALL   707
0B89:  BSF    0A.3
0B8A:  MOVLW  89
0B8B:  MOVWF  04
0B8C:  MOVF   43,W
0B8D:  BSF    03.5
0B8E:  MOVWF  31
0B8F:  BCF    03.5
0B90:  MOVF   42,W
0B91:  BSF    03.5
0B92:  MOVWF  30
0B93:  BCF    03.5
0B94:  MOVF   41,W
0B95:  BSF    03.5
0B96:  MOVWF  2F
0B97:  BCF    03.5
0B98:  MOVF   40,W
0B99:  BSF    03.5
0B9A:  MOVWF  2E
0B9B:  MOVLW  02
0B9C:  MOVWF  32
0B9D:  BCF    03.5
0B9E:  CALL   000
0B9F:  MOVLW  0A
0BA0:  BSF    03.5
0BA1:  MOVWF  3B
0BA2:  BCF    0A.3
0BA3:  BCF    03.5
0BA4:  CALL   707
0BA5:  BSF    0A.3
....................                 } 
....................             } 
....................        } 
....................         
....................        if (umSegundo) 
0BA6:  BTFSS  51.0
0BA7:  GOTO   4AB
....................        { 
....................             e_anterior = e_atual; 
0BA8:  MOVF   4B,W
0BA9:  MOVWF  4F
0BAA:  MOVF   4A,W
0BAB:  MOVWF  4E
0BAC:  MOVF   49,W
0BAD:  MOVWF  4D
0BAE:  MOVF   48,W
0BAF:  MOVWF  4C
....................             e_atual = r - y; //Erro == resposta - setPoint 
0BB0:  BSF    03.1
0BB1:  MOVF   3F,W
0BB2:  BSF    03.5
0BB3:  MOVWF  44
0BB4:  BCF    03.5
0BB5:  MOVF   3E,W
0BB6:  BSF    03.5
0BB7:  MOVWF  43
0BB8:  BCF    03.5
0BB9:  MOVF   3D,W
0BBA:  BSF    03.5
0BBB:  MOVWF  42
0BBC:  BCF    03.5
0BBD:  MOVF   3C,W
0BBE:  BSF    03.5
0BBF:  MOVWF  41
0BC0:  BCF    03.5
0BC1:  MOVF   3B,W
0BC2:  BSF    03.5
0BC3:  MOVWF  48
0BC4:  BCF    03.5
0BC5:  MOVF   3A,W
0BC6:  BSF    03.5
0BC7:  MOVWF  47
0BC8:  BCF    03.5
0BC9:  MOVF   39,W
0BCA:  BSF    03.5
0BCB:  MOVWF  46
0BCC:  BCF    03.5
0BCD:  MOVF   38,W
0BCE:  BSF    03.5
0BCF:  MOVWF  45
0BD0:  BCF    0A.3
0BD1:  BCF    03.5
0BD2:  CALL   47B
0BD3:  BSF    0A.3
0BD4:  MOVF   7A,W
0BD5:  MOVWF  4B
0BD6:  MOVF   79,W
0BD7:  MOVWF  4A
0BD8:  MOVF   78,W
0BD9:  MOVWF  49
0BDA:  MOVF   77,W
0BDB:  MOVWF  48
....................         
....................             u_anterior = u_atual; 
0BDC:  MOVF   43,W
0BDD:  MOVWF  47
0BDE:  MOVF   42,W
0BDF:  MOVWF  46
0BE0:  MOVF   41,W
0BE1:  MOVWF  45
0BE2:  MOVF   40,W
0BE3:  MOVWF  44
....................             u_atual = u_anterior + Kp*e_atual - Kp*(1-T/Ti)*e_anterior; //Saida do PID(PI) 
0BE4:  MOVLW  E4
0BE5:  BSF    03.5
0BE6:  MOVWF  52
0BE7:  MOVLW  38
0BE8:  MOVWF  51
0BE9:  MOVLW  0E
0BEA:  MOVWF  50
0BEB:  MOVLW  7F
0BEC:  MOVWF  4F
0BED:  BCF    03.5
0BEE:  MOVF   4B,W
0BEF:  BSF    03.5
0BF0:  MOVWF  56
0BF1:  BCF    03.5
0BF2:  MOVF   4A,W
0BF3:  BSF    03.5
0BF4:  MOVWF  55
0BF5:  BCF    03.5
0BF6:  MOVF   49,W
0BF7:  BSF    03.5
0BF8:  MOVWF  54
0BF9:  BCF    03.5
0BFA:  MOVF   48,W
0BFB:  BSF    03.5
0BFC:  MOVWF  53
0BFD:  BCF    0A.3
0BFE:  BCF    03.5
0BFF:  CALL   404
0C00:  BSF    0A.3
0C01:  BCF    03.1
0C02:  MOVF   47,W
0C03:  BSF    03.5
0C04:  MOVWF  44
0C05:  BCF    03.5
0C06:  MOVF   46,W
0C07:  BSF    03.5
0C08:  MOVWF  43
0C09:  BCF    03.5
0C0A:  MOVF   45,W
0C0B:  BSF    03.5
0C0C:  MOVWF  42
0C0D:  BCF    03.5
0C0E:  MOVF   44,W
0C0F:  BSF    03.5
0C10:  MOVWF  41
0C11:  MOVF   7A,W
0C12:  MOVWF  48
0C13:  MOVF   79,W
0C14:  MOVWF  47
0C15:  MOVF   78,W
0C16:  MOVWF  46
0C17:  MOVF   77,W
0C18:  MOVWF  45
0C19:  BCF    0A.3
0C1A:  BCF    03.5
0C1B:  CALL   47B
0C1C:  BSF    0A.3
0C1D:  MOVF   7A,W
0C1E:  BSF    03.5
0C1F:  MOVWF  31
0C20:  MOVF   79,W
0C21:  MOVWF  30
0C22:  MOVF   78,W
0C23:  MOVWF  2F
0C24:  MOVF   77,W
0C25:  MOVWF  2E
0C26:  MOVLW  50
0C27:  MOVWF  52
0C28:  MOVLW  74
0C29:  MOVWF  51
0C2A:  CLRF   50
0C2B:  MOVLW  7F
0C2C:  MOVWF  4F
0C2D:  BCF    03.5
0C2E:  MOVF   4F,W
0C2F:  BSF    03.5
0C30:  MOVWF  56
0C31:  BCF    03.5
0C32:  MOVF   4E,W
0C33:  BSF    03.5
0C34:  MOVWF  55
0C35:  BCF    03.5
0C36:  MOVF   4D,W
0C37:  BSF    03.5
0C38:  MOVWF  54
0C39:  BCF    03.5
0C3A:  MOVF   4C,W
0C3B:  BSF    03.5
0C3C:  MOVWF  53
0C3D:  BCF    0A.3
0C3E:  BCF    03.5
0C3F:  CALL   404
0C40:  BSF    0A.3
0C41:  BSF    03.1
0C42:  BSF    03.5
0C43:  MOVF   31,W
0C44:  MOVWF  44
0C45:  MOVF   30,W
0C46:  MOVWF  43
0C47:  MOVF   2F,W
0C48:  MOVWF  42
0C49:  MOVF   2E,W
0C4A:  MOVWF  41
0C4B:  MOVF   7A,W
0C4C:  MOVWF  48
0C4D:  MOVF   79,W
0C4E:  MOVWF  47
0C4F:  MOVF   78,W
0C50:  MOVWF  46
0C51:  MOVF   77,W
0C52:  MOVWF  45
0C53:  BCF    0A.3
0C54:  BCF    03.5
0C55:  CALL   47B
0C56:  BSF    0A.3
0C57:  MOVF   7A,W
0C58:  MOVWF  43
0C59:  MOVF   79,W
0C5A:  MOVWF  42
0C5B:  MOVF   78,W
0C5C:  MOVWF  41
0C5D:  MOVF   77,W
0C5E:  MOVWF  40
0C5F:  CLRF   27
0C60:  BTFSC  0B.7
0C61:  BSF    27.7
0C62:  BCF    0B.7
....................              
....................             if (u_atual > 60) u_atual = 60.0f; 
0C63:  BSF    03.5
0C64:  CLRF   5F
0C65:  CLRF   5E
0C66:  MOVLW  70
0C67:  MOVWF  5D
0C68:  MOVLW  84
0C69:  MOVWF  5C
0C6A:  BCF    03.5
0C6B:  MOVF   43,W
0C6C:  BSF    03.5
0C6D:  MOVWF  63
0C6E:  BCF    03.5
0C6F:  MOVF   42,W
0C70:  BSF    03.5
0C71:  MOVWF  62
0C72:  BCF    03.5
0C73:  MOVF   41,W
0C74:  BSF    03.5
0C75:  MOVWF  61
0C76:  BCF    03.5
0C77:  MOVF   40,W
0C78:  BSF    03.5
0C79:  MOVWF  60
0C7A:  BCF    0A.3
0C7B:  BCF    03.5
0C7C:  CALL   0A6
0C7D:  BSF    0A.3
0C7E:  BTFSC  27.7
0C7F:  BSF    0B.7
0C80:  BTFSS  03.0
0C81:  GOTO   488
0C82:  CLRF   43
0C83:  CLRF   42
0C84:  MOVLW  70
0C85:  MOVWF  41
0C86:  MOVLW  84
0C87:  MOVWF  40
0C88:  CLRF   27
0C89:  BTFSC  0B.7
0C8A:  BSF    27.7
0C8B:  BCF    0B.7
....................             if (u_atual < 00) u_atual = 0.0f; 
0C8C:  MOVF   43,W
0C8D:  BSF    03.5
0C8E:  MOVWF  5F
0C8F:  BCF    03.5
0C90:  MOVF   42,W
0C91:  BSF    03.5
0C92:  MOVWF  5E
0C93:  BCF    03.5
0C94:  MOVF   41,W
0C95:  BSF    03.5
0C96:  MOVWF  5D
0C97:  BCF    03.5
0C98:  MOVF   40,W
0C99:  BSF    03.5
0C9A:  MOVWF  5C
0C9B:  CLRF   63
0C9C:  CLRF   62
0C9D:  CLRF   61
0C9E:  CLRF   60
0C9F:  BCF    0A.3
0CA0:  BCF    03.5
0CA1:  CALL   0A6
0CA2:  BSF    0A.3
0CA3:  BTFSC  27.7
0CA4:  BSF    0B.7
0CA5:  BTFSS  03.0
0CA6:  GOTO   4AB
0CA7:  CLRF   43
0CA8:  CLRF   42
0CA9:  CLRF   41
0CAA:  CLRF   40
....................        } 
....................         
....................        if (meioSegundo) 
0CAB:  BTFSS  51.1
0CAC:  GOTO   4EF
....................        { 
....................          static char st[]="S.P.: "; 
*
0A3D:  MOVLW  53
0A3E:  BSF    03.5
0A3F:  MOVWF  20
0A40:  MOVLW  2E
0A41:  MOVWF  21
0A42:  MOVLW  50
0A43:  MOVWF  22
0A44:  MOVLW  2E
0A45:  MOVWF  23
0A46:  MOVLW  3A
0A47:  MOVWF  24
0A48:  MOVLW  20
0A49:  MOVWF  25
0A4A:  CLRF   26
....................          static char ta[]="T.A.: "; 
0A4B:  MOVLW  54
0A4C:  MOVWF  27
0A4D:  MOVLW  2E
0A4E:  MOVWF  28
0A4F:  MOVLW  41
0A50:  MOVWF  29
0A51:  MOVLW  2E
0A52:  MOVWF  2A
0A53:  MOVLW  3A
0A54:  MOVWF  2B
0A55:  MOVLW  20
0A56:  MOVWF  2C
0A57:  CLRF   2D
....................          home(); 
*
0CAD:  BCF    0A.3
0CAE:  CALL   3F9
0CAF:  BSF    0A.3
....................          clear(); 
0CB0:  BCF    0A.3
0CB1:  CALL   3EE
0CB2:  BSF    0A.3
....................          printstr(ta); 
0CB3:  BSF    03.5
0CB4:  CLRF   43
0CB5:  MOVLW  A7
0CB6:  MOVWF  42
0CB7:  BCF    0A.3
0CB8:  BCF    03.5
0CB9:  CALL   790
0CBA:  BSF    0A.3
....................          printfloat(y); 
0CBB:  MOVF   3B,W
0CBC:  BSF    03.5
0CBD:  MOVWF  31
0CBE:  BCF    03.5
0CBF:  MOVF   3A,W
0CC0:  BSF    03.5
0CC1:  MOVWF  30
0CC2:  BCF    03.5
0CC3:  MOVF   39,W
0CC4:  BSF    03.5
0CC5:  MOVWF  2F
0CC6:  BCF    03.5
0CC7:  MOVF   38,W
0CC8:  BSF    03.5
0CC9:  MOVWF  2E
0CCA:  BCF    0A.3
0CCB:  BCF    03.5
0CCC:  CALL   7C1
0CCD:  BSF    0A.3
....................          setCursor(0, 1); 
0CCE:  BSF    03.5
0CCF:  CLRF   2E
0CD0:  MOVLW  01
0CD1:  MOVWF  2F
0CD2:  BCF    03.5
0CD3:  GOTO   1D4
....................          printstr(st); 
0CD4:  BSF    03.5
0CD5:  CLRF   43
0CD6:  MOVLW  A0
0CD7:  MOVWF  42
0CD8:  BCF    0A.3
0CD9:  BCF    03.5
0CDA:  CALL   790
0CDB:  BSF    0A.3
....................          printfloat(r); 
0CDC:  MOVF   3F,W
0CDD:  BSF    03.5
0CDE:  MOVWF  31
0CDF:  BCF    03.5
0CE0:  MOVF   3E,W
0CE1:  BSF    03.5
0CE2:  MOVWF  30
0CE3:  BCF    03.5
0CE4:  MOVF   3D,W
0CE5:  BSF    03.5
0CE6:  MOVWF  2F
0CE7:  BCF    03.5
0CE8:  MOVF   3C,W
0CE9:  BSF    03.5
0CEA:  MOVWF  2E
0CEB:  BCF    0A.3
0CEC:  BCF    03.5
0CED:  CALL   7C1
0CEE:  BSF    0A.3
....................        } 
....................        //setCursor(0, 1); 
....................       // printfloat(u_atual); 
....................         
....................        resetTimes(); 
0CEF:  BCF    0A.3
0CF0:  GOTO   7E6
0CF1:  BSF    0A.3
0CF2:  GOTO   332
....................        //resetTimes(); 
....................    } 
....................  
.................... } 
0CF3:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
